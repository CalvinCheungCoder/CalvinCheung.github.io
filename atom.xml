<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DHTalk&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/a24aa8527776dc09eefc03ed45e735e4</icon>
  <subtitle>Stay hungry Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://CalvinCheung.coding.me/"/>
  <updated>2019-05-07T16:22:51.096Z</updated>
  <id>http://CalvinCheung.coding.me/</id>
  
  <author>
    <name>Calvin</name>
    <email>zhangdinghao1993@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo 博客常用指令</title>
    <link href="http://CalvinCheung.coding.me/2019/05/08/hexo-commands/"/>
    <id>http://CalvinCheung.coding.me/2019/05/08/hexo-commands/</id>
    <published>2019-05-07T16:12:02.000Z</published>
    <updated>2019-05-07T16:22:51.096Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/commands.html</a></p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo init [folder]</div></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <a href="">folder</a> ，Hexo 默认在目前的文件夹建立网站。</p><p>###new</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="external">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;post title with whitespace&quot;</div></pre></td></tr></table></figure><p>###generate</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo g</div></pre></td></tr></table></figure><p>###publish</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;filename&gt;</div></pre></td></tr></table></figure><p>发表草稿。</p><p>###server</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p, –port</td><td>重设端口</td></tr><tr><td>-s, –static</td><td>只使用静态文件</td></tr><tr><td>-l, –log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><p>###deploy<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p><p>部署网站。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-g, –generate</td><td>部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo d</div></pre></td></tr></table></figure></p><p>###render<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo render &lt;file1&gt; [file2] ...</div></pre></td></tr></table></figure></p><p>渲染文件。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-o, –output</td><td>设置输出路径</td></tr></tbody></table><p>###migrate<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo migrate &lt;type&gt;</div></pre></td></tr></table></figure></p><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="external">迁移内容</a>。</p><p>###clean<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure></p><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>###list<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo list &lt;type&gt;</div></pre></td></tr></table></figure></p><p>列出网站资料。</p><p>###version<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo version</div></pre></td></tr></table></figure></p><p>显示 Hexo 版本。</p><p>###选项</p><p>###安全模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --safe</div></pre></td></tr></table></figure></p><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><p>###调试模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --debug</div></pre></td></tr></table></figure></p><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，<a href="https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo%2Fissues%2Fnew" target="_blank" rel="external">并提交调试信息到 GitHub</a>。</p><p>###简洁模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --silent</div></pre></td></tr></table></figure></p><p>隐藏终端信息。</p><p>###自定义配置文件的路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --config custom.yml</div></pre></td></tr></table></figure></p><p>自定义配置文件的路径，执行后将不再使用 <code>_config.yml</code>。</p><p>###显示草稿<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --draft</div></pre></td></tr></table></figure></p><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><p>###自定义 CWD<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo --cwd /path/to/cwd</div></pre></td></tr></table></figure></p><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;https://hexo.io/zh-cn/docs/commands.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/zh-cn/docs/commands.html&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL 支持 emoji 图标存储</title>
    <link href="http://CalvinCheung.coding.me/2019/02/19/mysql-use-emoji/"/>
    <id>http://CalvinCheung.coding.me/2019/02/19/mysql-use-emoji/</id>
    <published>2019-02-19T14:13:43.000Z</published>
    <updated>2019-03-02T11:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>MySLQ</code>中 <code>UPDATA</code> 和 <code>INSERT</code> 数据的时候，如果数据上面带有<code>emoji</code>图标，例如：?、?、? 很容易更新或者插入不成功，导致报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Error: ER_TRUNCATED_WRONG_VALUE_FOR_FIELD: </div><div class="line">Incorrect string value: &apos;\xF0\x9F\x91\xBD\xF0\x9F...&apos; for column &apos;name&apos; at row</div></pre></td></tr></table></figure><p>都快崩溃了，但是还好终于解决了这种鬼问题。资料显示原因是，<code>MYSQL 5.5</code> 之前， <code>UTF8</code> 编码只支持1-3个字节，只支持<code>BMP</code>这部分的<code>unicode</code>编码区，而<code>emoji</code>图标恰好是4个字节的编码进行存储。从<code>MYSQL5.5</code>开始，可支持4个字节<code>UTF</code>编码<code>utf8mb4</code>，一个字符最多能有4字节，所以能支持更多的字符集。所以要解决问题，必需把数据库表字符编码全部改成<code>utf8mb4</code>。</p><h3 id="常用字符集"><a href="#常用字符集" class="headerlink" title="常用字符集"></a>常用字符集</h3><ul><li>ASCII：美国信息互换标准编码；英语和其他西欧语言；单字节编码，7位表示一个字符，共128字符。</li><li>GBK：双字节，汉字内码扩展规范；中日韩汉字、英文、数字；双字节编码；共收录了21003个汉字，GB2312的扩展。</li><li>UTF-8：Unicode标准的可变长度字符编码；Unicode标准（统一码），业界统一标准，包括世界上数十种文字的系统；</li><li>UTF-8：使用一至三个字节为每个字符编码。</li><li>utf8mb4：存储四个字节，应用场景用于存储emoji表情，因为可以emoji表情四个字节。</li><li>utf8mb4：MySQL版本 &gt; 5.5.3 。</li><li>其他常见字符集：UTF-32，UTF-16，Big5，latin1</li><li>数据库中的字符集包含两层含义<br>  1.各种文字和符号的集合，包括各国家文字、标点符号、图形符号、数字等。<br>  2.字符的编码方式，即二进制数据与字符的映射规则。</li></ul><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>MySQL 5.7.14<br>Mac OSX 10.11.6</p><h3 id="首先备份"><a href="#首先备份" class="headerlink" title="首先备份"></a>首先备份</h3><p>升级数据之前备份您服务器上的所有数据，保持良好习惯，安全第一！</p><h3 id="升级您的MySQL"><a href="#升级您的MySQL" class="headerlink" title="升级您的MySQL"></a>升级您的MySQL</h3><p>新的数据库可以在这里下载<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">Upgrade the MySQL server to v5.5.3+</a>。</p><p>###修改您的数据库、表、字段<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 对每一个数据库:</div><div class="line">ALTER DATABASE 这里数据库名字 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;</div><div class="line"># 对每一个表:</div><div class="line">ALTER TABLE 这里是表名字 CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</div><div class="line"># 对每一个字段:</div><div class="line">ALTER TABLE 这里是表名字 CHANGE 字段名字 重复字段名字 VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</div><div class="line"># 上面一句或者使用modify来更改</div><div class="line">ALTER TABLE 这里是表名字 modify 字段名字 VARCHAR(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT &apos;&apos;;</div></pre></td></tr></table></figure></p><p><code>utf8mb4</code>完全向后兼容<code>utf8</code>，无乱码或其他数据丢失的形式出现。理论上是可以放心修改，如果您不放心修改，您可以拿备份恢复数据，然后让程序员处理这种兼容<code>emoji</code>存储问题，存的时候过滤一遍转成<code>base64</code>，然后取的时候转回来？… 还是修改数据库比较方便。</p><h3 id="检查你的字段和索引"><a href="#检查你的字段和索引" class="headerlink" title="检查你的字段和索引"></a>检查你的字段和索引</h3><p>不要将所有的都设置成<code>utf8mb4</code>，这个冒得必要。我只在我某些字段类型为<code>VARCHAR</code>的时候才设置成<code>utf8mb4</code>。</p><h3 id="修改MySQL配置文件"><a href="#修改MySQL配置文件" class="headerlink" title="修改MySQL配置文件"></a>修改MySQL配置文件</h3><p>这个地方最坑，我在我Mac osx 系统上找不到<code>/etc/my.cnf</code> 它根本不存在，所以我们需要创建这样一个文件并修改它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 进入这个目录，</div><div class="line"># 在这个目录下面有个后缀为`.cnf`的文件</div><div class="line">cd /usr/local/mysql/support-files/</div><div class="line"></div><div class="line"># 将这个文件复制到`etc`目录中并将名字命名为`my.cnf`</div><div class="line">sudo cp my-default.cnf /etc/my.cnf</div><div class="line"></div><div class="line"># 然后编辑`my.cnf`文件，将下面内容复制到里面。</div><div class="line">sudo vim /etc/my.cnf</div></pre></td></tr></table></figure><p><a href="https://dev.mysql.com/doc/refman/5.5/en/option-files.html" target="_blank" rel="external">MySQL configuration file (/etc/my.cnf):</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[client]</div><div class="line">default-character-set = utf8mb4</div><div class="line"></div><div class="line">[mysql]</div><div class="line">default-character-set = utf8mb4</div><div class="line"></div><div class="line">[mysqld]</div><div class="line">character-set-client-handshake = FALSE</div><div class="line">character-set-server = utf8mb4</div><div class="line">collation-server = utf8mb4_unicode_ci</div></pre></td></tr></table></figure><h3 id="重启MySQL"><a href="#重启MySQL" class="headerlink" title="重启MySQL"></a>重启MySQL</h3><p>重启步骤很重要，不然没有任何效果。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">启动：/usr/local/mysql/support-files/mysql.server start</div><div class="line">停止：/usr/local/mysql/support-files/mysql.server stop</div><div class="line">重启：/usr/local/mysql/support-files/mysql.server restart</div></pre></td></tr></table></figure><p>系统中可以以这种形式重启、停止或启动</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">service mysqld stop</div><div class="line">service mysqld start</div><div class="line">service mysqld restart</div></pre></td></tr></table></figure><h3 id="查看是否设置成功"><a href="#查看是否设置成功" class="headerlink" title="查看是否设置成功"></a>查看是否设置成功</h3><p>通过下面命令查询是否设置成功！</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 登陆MySQL进行查询</div><div class="line">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE &apos;character\_set\_%&apos; OR Variable_name LIKE &apos;collation%&apos;;</div><div class="line"></div><div class="line"># 运行上面代码显示下面结果</div><div class="line"># +--------------------------+--------------------+</div><div class="line"># | Variable_name            | Value              |</div><div class="line"># +--------------------------+--------------------+</div><div class="line"># | character_set_client     | utf8mb4            |</div><div class="line"># | character_set_connection | utf8mb4            |</div><div class="line"># | character_set_database   | utf8mb4            |</div><div class="line"># | character_set_filesystem | binary             |</div><div class="line"># | character_set_results    | utf8mb4            |</div><div class="line"># | character_set_server     | utf8mb4            |</div><div class="line"># | character_set_system     | utf8               |</div><div class="line"># | collation_connection     | utf8mb4_unicode_ci |</div><div class="line"># | collation_database       | utf8mb4_unicode_ci |</div><div class="line"># | collation_server         | utf8mb4_unicode_ci |</div><div class="line"># +--------------------------+--------------------+</div><div class="line"></div><div class="line"># 查看表的情况</div><div class="line">mysql&gt;  SHOW FULL COLUMNS  FROM  users_profile;</div></pre></td></tr></table></figure><p>到这一步表示你成功了！恭喜你！~</p><h3 id="修复和优化表"><a href="#修复和优化表" class="headerlink" title="修复和优化表"></a>修复和优化表</h3><p>我跑到这一步其实没有任何必要修复和优化表，为了保险起见，我还是运行了这两条命令，虽然不知道它有什么卵用，放在这里做个笔记吧。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">REPAIR TABLE 表名字;</div><div class="line">OPTIMIZE TABLE 表名字;</div></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mathiasbynens.be/notes/mysql-utf8mb4#character-sets" target="_blank" rel="external">How to support full Unicode in MySQL databases</a></li><li><a href="https://forums.mysql.com/read.php?11,366143,376017#msg-376017" target="_blank" rel="external">my.cnf file does not exist on Mac OSX</a></li></ul><p><a href="https://segmentfault.com/a/1190000006851140" target="_blank" rel="external">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;MySLQ&lt;/code&gt;中 &lt;code&gt;UPDATA&lt;/code&gt; 和 &lt;code&gt;INSERT&lt;/code&gt; 数据的时候，如果数据上面带有&lt;code&gt;emoji&lt;/code&gt;图标，例如：?、?、? 很容易更新或者插入不成功，导致报错。&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="DevTips" scheme="http://CalvinCheung.coding.me/categories/DevTips/"/>
    
    
      <category term="MySQL" scheme="http://CalvinCheung.coding.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>EOS 错误码整理</title>
    <link href="http://CalvinCheung.coding.me/2019/02/18/eos-errorlist/"/>
    <id>http://CalvinCheung.coding.me/2019/02/18/eos-errorlist/</id>
    <published>2019-02-18T14:24:12.000Z</published>
    <updated>2019-02-18T14:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>EOS 目前大约有180种错误类型，虽然有错误码，但是还是很笼统的，具体的报错信息还得看detail里面的内容</p><h3 id="一、常见的错误码以及issue上对应的错误记录"><a href="#一、常见的错误码以及issue上对应的错误记录" class="headerlink" title="一、常见的错误码以及issue上对应的错误记录"></a>一、常见的错误码以及issue上对应的错误记录</h3><p>3010001 Invalid name<br>账户名格式1-12位（a-z，1-5，“.” ) 且”.”不能在首尾<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010001" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010001</a></p><p>3010004 Invalid authority<br>检查 authorization”: [{<br>“actor”: “accountname1”,<br>“permission”: “active”<br>}] 参数是否填写正确<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010004" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010004</a></p><p>3010008 Invalid block ID<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010008" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010008</a></p><p>3010010 Invalid packed transaction<br>一般报这个错误就是打包交易的参数传的不正确<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010010" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010010</a></p><p>3010011 Invalid asset<br>检查资产格式是否正确<br>如”stake_net_quantity”:”0.0001 EOS” 1.确保正确的精度 空格加Symbol<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010011" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3010011</a></p><p>3030000 Block exception<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030000" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030000</a></p><p>3030001 Unlinkable block<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030001" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030001</a></p><p>3030002 Transaction outputs in block do not match transaction outputs from applying block<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030002" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030002</a></p><p>3030003 Block does not guarantee concurrent execution without conflicts<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030003" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030003</a></p><p>3030008 Block is not signed with expected key<br>检查是否对块信息签名<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030008" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3030008</a></p><p>3040000 Transaction exception<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040000" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040000</a></p><p>3040002 Transaction should have at least one normal action<br>查看action是否添加，是否正确<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040002" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040002</a></p><p>3040005 Expired Transaction<br>交易过期，过期时间可以设置长一点<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040005" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3040005</a></p><p>3040006 Transaction Expiration Too Far<br>过期时间设置太长</p><p>3040007 Invalid Reference Block<br>引用块无效或不匹配，节点间不同有关<br><a href="https://github.com/EOSIO/eos/issues/4659" target="_blank" rel="external">https://github.com/EOSIO/eos/issues/4659</a></p><p>3050000 Action validate exception<br>检查Action是否正确<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3050000" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3050000</a></p><p>3050001 Account name already exists<br>账户名已存在</p><p>3050002 Invalid Action Arguments<br>检查Action参数<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3050002" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3050002</a></p><p>3050003 eosio_assert_message assertion failure<br>账户不存在，资产金额不正确等</p><p>3060003 Contract Table Query Exception<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3060003" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3060003</a></p><p>3060004 Contract Query Exception<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3060004" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3060004</a></p><p>3070002 Runtime Error Processing WASM<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3070002" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3070002</a></p><p>3080001 Account using more than allotted RAM usage<br>内存不足，买些内存</p><p>3080002 Transaction exceeded the current network usage limit imposed on the transaction<br>网络资源不足，抵押一些资源</p><p>3080004 Transaction exceeded the current CPU usage limit imposed on the transaction<br>CPU不足，抵押一些CPU</p><p>3080006 Transaction took too long<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3080006+" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3080006+</a></p><p>3081001 Transaction reached the deadline set due to leeway on account CPU limits<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3081001" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3081001</a></p><p>3090003 Provided keys, permissions, and delays do not satisfy declared authorizations<br>检查权限，签名等是否正确<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3090003" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3090003</a></p><p>3090004 Missing required authority<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3090004" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3090004</a></p><p>3110001 Missing Chain API Plugin<br><a href="https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3110001" target="_blank" rel="external">https://github.com/EOSIO/eos/issues?utf8=%E2%9C%93&amp;q=3110001</a></p><h3 id="二、EOS-错误码大全"><a href="#二、EOS-错误码大全" class="headerlink" title="二、EOS 错误码大全"></a>二、EOS 错误码大全</h3><p>3000000 blockchain exception<br>3010001 Invalid name<br>3010002 Invalid public key<br>3010003 Invalid private key<br>3010004 Invalid authority<br>3010005 Invalid action<br>3010006 Invalid transaction<br>3010007 Invalid ABI<br>3010008 Invalid block ID<br>3010009 Invalid transaction ID<br>3010010 Invalid packed transaction<br>3010011 Invalid asset<br>3010012 Invalid chain ID<br>3010013 Invalid fixed key<br>3010014 Invalid symbol<br>3020000 Fork database exception<br>3020001 Block can not be found<br>3030000 Block exception<br>3030001 Unlinkable block<br>3030002 Transaction outputs in block do not match transaction outputs from applying block 交易不匹配<br>3030003 Block does not guarantee concurrent execution without conflicts<br>3030004 Shard locks in block are incorrect or mal-formed<br>3030005 Block exhausted allowed resources<br>3030006 Block is too old to push<br>3030007 Block is from the future<br>3030008 Block is not signed with expected key<br>3030009 Block is not signed by expected producer<br>3040000 Transaction exception<br>3040001 Error decompressing transaction<br>3040002 Transaction should have at least one normal action<br>3040003 Transaction should have at least one required authority<br>3040004 Context-free action should have no required authority<br>3040005 Expired Transaction<br>3040006 Transaction Expiration Too Far<br>3040007 Invalid Reference Block<br>3040008 Duplicate transaction<br>3040009 Duplicate deferred transaction<br>3040010 Context free action is not allowed inside generated Transaction<br>3040011 The transaction can not be found<br>3040012 Pushing too many transactions at once<br>3040013 Transaction is too big<br>3040014 Unknown transaction compression<br>3050000 Action validate exception<br>3050001 Account name already exists<br>3050002 Invalid Action Arguments<br>3050003 eosio_assert_message assertion failure<br>3050004 eosio_assert_code assertion failure<br>3050005 Action can not be found<br>3050006 Mismatch between action data and its struct<br>3050007 Attempt to use unaccessible API<br>3050008 Abort Called<br>3050009 Inline Action exceeds maximum size limit<br>3060000 Database exception<br>3060001 Permission Query Exception<br>3060002 Account Query Exception<br>3060003 Contract Table Query Exception<br>3060004 Contract Query Exception<br>3060100 Database exception<br>3060101 Database usage is at unsafe levels<br>3060102 Reversible block log usage is at unsafe levels<br>3070000 WASM Exception<br>3070001 Error in WASM page memory<br>3070002 Runtime Error Processing WASM<br>3070003 Serialization Error Processing WASM<br>3070004 memcpy with overlapping memory<br>3070005 binaryen exception<br>3080000 Resource exhausted exception<br>3080001 Account using more than allotted RAM usage<br>3080002 Transaction exceeded the current network usage limit imposed on the transaction<br>3080003 Transaction network usage is too much for the remaining allowable usage of the current block<br>3080004 Transaction exceeded the current CPU usage limit imposed on the transaction<br>3080005 Transaction CPU usage is too much for the remaining allowable usage of the current block<br>3080006 Transaction took too long<br>3080007 Transaction exceeded the current greylisted account network usage limit<br>3081001 Transaction reached the deadline set due to leeway on account CPU limits<br>3090000 Authorization exception<br>3090001 Duplicate signature included<br>3090002 Irrelevant signature included<br>3090003 Provided keys, permissions, and delays do not satisfy declared authorizations<br>3090004 Missing required authority<br>3090005 Irrelevant authority included<br>3090006 Insufficient delay<br>3090007 Invalid Permission<br>3090008 The action is not allowed to be linked with minimum permission<br>3090009 The parent permission is invalid<br>3100000 Miscellaneous exception<br>3100001 Internal state is no longer consistent<br>3100002 Unknown bloc<br>3100003 Unknown transaction<br>3100004 Corrupted reversible block database was fixed<br>3100005 Extracted genesis state from blocks.log<br>3100006 Subjective exception thrown during block production<br>3100007 Multiple voter info detected<br>3100008 Feature is currently unsupported<br>3100009 Node management operation successfully executed<br>3110000 Plugin exception<br>3110001 Missing Chain API Plugin<br>3110002 Missing Wallet API Plugin<br>3110003 Missing History API Plugin<br>3110004 Missing Net API Plugin<br>3110005 Missing Chain Plugin<br>3110006 Incorrect plugin configuration<br>3120000 Wallet exception<br>3120001 Wallet already exists<br>3120002 Nonexistent wallet<br>3120003 Locked wallet<br>3120004 Missing public key<br>3120005 Invalid wallet password<br>3120006 No available wallet<br>3120007 Already unlocked<br>3120008 Key already exists<br>3120009 Nonexistent key<br>3120010 Unsupported key type<br>3120011 Wallet lock timeout is invalid<br>3120012 Secure Enclave Exception<br>3130000 Actor or contract whitelist/blacklist exception<br>3130001 Authorizing actor of transaction is not on the whitelist<br>3130002 Authorizing actor of transaction is on the blacklist<br>3130003 Contract to execute is not on the whitelist<br>3130004 Contract to execute is on the blacklist<br>3130005 Action to execute is on the blacklist<br>3130006 Public key in authority is on the blacklist<br>3140000 Exceptions that are allowed to bubble out of emit calls in controller<br>3140001 Block does not match checkpoint<br>3150000 ABI exception<br>3150001 No ABI found<br>3150002 Invalid Ricardian Clause<br>3150003 Invalid Ricardian Action<br>3150004 The type defined in the ABI is invalid<br>3150005 Duplicate type definition in the ABI<br>3150006 Duplicate struct definition in the ABI<br>3150007 Duplicate action definition in the ABI<br>3150008 uplicate table definition in the ABI<br>3150009 Duplicate error message definition in the ABI<br>3150010 ABI serialization time has exceeded the deadline<br>3150011 ABI recursive definition has exceeded the max recursion depth<br>3150012 Circular definition is detected in the ABI<br>3150013 Unpack data exception<br>3150014 Pack data exception<br>3160000 Contract exception<br>3160001 The payer of the table data is invalid<br>3160002 Table access violation<br>3160003 Invalid table iterator<br>3160004 Table can not be found inside the cache<br>3160005 The table operation is not allowed<br>3160006 Invalid contract vm type<br>3160007 Invalid contract vm version<br>3160008 Contract is already running this version of code<br>3160009 No wast file found<br>3160010 No abi file found<br>3170000 Producer exception<br>3170001 Producer private key is not available<br>3170002 Pending block state is missing<br>3170003 Producer is double confirming known rang<br>3170004 Producer schedule exception<br>3170006 The producer is not part of current schedule<br>3180000 Reversible Blocks exception<br>3180001 Invalid reversible blocks directory<br>3180002 Backup directory for reversible blocks already existg<br>3180003 Gap in the reversible blocks database<br>3190000 Block log exception<br>3190001 unsupported version of block log<br>3190002 fail to append block to the block log<br>3190003 block log can not be found<br>3190004 block log backup dir already exists<br>3200000 http exception<br>3200001 invalid http client root certificate<br>3200002 invalid http response<br>3200003 service resolved to multiple ports<br>3200004 fail to resolve host<br>3200005 http request fail<br>3200006 invalid http request<br>3210000 Resource limit exception<br>3220000 Mongo DB exception<br>3220001 Fail to insert new data to Mongo DB<br>3220002 Fail to update existing data in Mongo DB<br>3230000 Contract API exception<br>3230001 Crypto API Exception<br>3230002 Database API Exception<br>3230003 Arithmetic Exception</p><p><a href="http://blog.eosdata.io/index.php/2018/07/20/eos_errorcode/" target="_blank" rel="external">原文链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EOS 目前大约有180种错误类型，虽然有错误码，但是还是很笼统的，具体的报错信息还得看detail里面的内容&lt;/p&gt;
&lt;h3 id=&quot;一、常见的错误码以及issue上对应的错误记录&quot;&gt;&lt;a href=&quot;#一、常见的错误码以及issue上对应的错误记录&quot; class=&quot;he
      
    
    </summary>
    
      <category term="DevTips" scheme="http://CalvinCheung.coding.me/categories/DevTips/"/>
    
    
      <category term="EOS" scheme="http://CalvinCheung.coding.me/tags/EOS/"/>
    
  </entry>
  
  <entry>
    <title>2019 🇬🇧英国之行</title>
    <link href="http://CalvinCheung.coding.me/2019/02/16/2019-in-the-uk/"/>
    <id>http://CalvinCheung.coding.me/2019/02/16/2019-in-the-uk/</id>
    <published>2019-02-16T05:06:10.000Z</published>
    <updated>2019-02-16T08:20:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年春节没有回家而去了英国，年假加春节假期一起有半个月时间，期间大概有一周时间游览了英国的几个城市。当然，这次出行看似是旅行，实则属于探亲，所以游玩的几个城市也没刻意做任何攻略，全是自然的走走看看，随手拍。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1586.JPG" alt=""><br>希斯罗机场的地铁，由于 T5 和其他几个航站楼距离较远，所以可以在机场免费取一张地铁票前往其他航站楼。</p><h3 id="巴斯-Bath"><a href="#巴斯-Bath" class="headerlink" title="巴斯 Bath"></a>巴斯 Bath</h3><p>在巴斯玩了一天，这座城市很小，所以一天的游玩的时间就以足够。巴斯比较知名的几个景点是：普尔特尼三拱桥、罗马浴场博物馆、皇家新月楼、巴斯修道院、圆形广场、时装博物馆等。<br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0819.JPG" alt=""><br>普尔特尼三拱桥，从巴斯火车站出来直接走过来的，几分钟路程，大桥非常漂亮。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0820.JPG" alt=""><br>某街道</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0821.JPG" alt=""><br>双层观光巴士</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0822.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0853.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0854.JPG" alt=""><br>大众点评上比较受欢迎的一个网红餐厅，我们 11 点钟左右过去人还不多，餐厅不大，按照大众点评推荐菜吃的，食物很不错，人均也不贵。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0856.JPG" alt=""><br>皇家新月楼，和圆形广场距离没多远。因为当天下雨，所以草地上没人，偶尔也有游客在附近拍照。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0855.JPG" alt=""><br>皇家新月楼草地里的小松鼠</p><p>巴斯的景点很少，博物馆基本都是收费的，我们游玩当天天气还在下雨，所以只在服装博物馆玩了一下，门票价格好像是成人 9.5 磅，学生 8.5 磅。也有很多人打卡罗马浴场博物馆，我和我家那一位说对罗马帝国的澡堂子没兴趣，就没去看😄。</p><h3 id="温彻斯特-Winchester"><a href="#温彻斯特-Winchester" class="headerlink" title="温彻斯特 Winchester"></a>温彻斯特 Winchester</h3><p>又是一座小城，早起坐火车到达后先去了车站附近的一个公共图书馆坐了一会，然后沿着这个城市的主街道游览。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1546.JPG" alt=""><br>当地的星巴克，如果你在店内饮用，可以选择马克杯更环保。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1547.JPG" alt=""><br>街道上某英式餐厅摆的车和花</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0946.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0947.JPG" alt=""><br>Statue of Alfred the Great 和素描的人</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0948.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0952.JPG" alt=""><br>伊丽莎白女王灯，在英国很多的街道都有，行人可以在有此灯的路口直接穿行，当行人步行穿过街道时车辆必须停车等待。当然英国过马路很多时候都是车礼让行人。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0949.JPG" alt="">、<br>Winchester City Museum 城市博物馆门口偶遇 “TNT”</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0950.JPG" alt=""><br>小小的街道和行人</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_0951.JPG" alt=""><br>Winchester Cathedral 温彻斯特大教堂</p><h3 id="伦敦-London"><a href="#伦敦-London" class="headerlink" title="伦敦 London"></a>伦敦 London</h3><p>伦敦有太多好玩并且免费的地方了，我们在伦敦待了将近 4 天，加上天气也不是特别好，所以只打卡了几个主要的景点。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1548.JPG" alt=""><br>到伦敦先办一张 oyster 地铁卡，此卡押金 5 磅，如果你在伦敦待不了多久充值不要太多，哪怕多次小额充值也可以，因为当你离开伦敦要退卡时，如果卡里面的余额超过 10 磅会很麻烦，如果你有 Young Person Railcard 可以在大的地铁站和此卡绑定，这样坐地铁的价格会优惠 1/3，当然你有了 Young Person Railcard，在英国买汽车和火车票也可以优惠 1/3。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1549.JPG" alt=""><br>肯辛顿宫花园</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1550.JPG" alt=""><br>在亚伯特纪念碑前拍皇家地理学会</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1551.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1552.JPG" alt=""><br>科学博物馆中的 AppleII 和太空舱</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1554.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1553.JPG" alt=""><br>自然历史博物馆门前 33 米长的蓝鲸标本和旁边的长颈鹿标本</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1555.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1557.JPG" alt=""><br>伦敦街头随处可见的双层巴士以及不再使用的电话亭</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1556.JPG" alt=""><br>伦敦街头的摩拜单车</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1585.JPG" alt=""><br>尚未开业的海底捞火锅</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1558.JPG" alt=""><br>大英博物馆正门</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1559.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1560.JPG" alt=""><br>大英博物馆旁的罗素广场</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1561.JPG" alt=""><br>泰晤士河畔的涂鸦和滑板</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1562.JPG" alt=""><br>夜晚中的伦敦眼，而在身后的大本钟正在整修。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1565.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1566.JPG" alt=""><br>诺丁山道路旁漂亮的房子和出来游玩逛集市的人们</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1564.JPG" alt=""><br>诺丁山某道路旁的老旧小汽车</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1567.JPG" alt=""><br>海德公园不怕人的动物们</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1569.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1570.JPG" alt=""><br>伦敦中国城的灯笼和表演的艺人</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1571.JPG" alt=""><br>特拉法加广场附近非常搞笑的 5 个黑人小哥在表演街舞</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1572.JPG" alt=""><br>特拉法加广场某人使用粉笔画的</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1573.JPG" alt=""><br>伦敦的地铁，这算是比较新的线路和车子了。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1574.JPG" alt=""><br>帕丁顿车站内</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1584.JPG" alt=""><br>伦敦国家美术馆内梵高的向日葵</p><h3 id="牛津-Oxford"><a href="#牛津-Oxford" class="headerlink" title="牛津 Oxford"></a>牛津 Oxford</h3><p>牛津也是很小的一座城市，在牛津玩没有特意打卡景点，就在街道随便走走，逛逛当地的市场什么的。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1575.JPG" alt=""><br>牛津公园里一个偏僻角落的 ofo</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1576.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1577.JPG" alt=""><br><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1578.JPG" alt=""><br>牛津自然博物馆</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/2019-UK/IMG_1579.JPG" alt=""><br>奈何桥</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1、对英国有一个浅薄的观察，那就是街道、房子和车子等都很小，这可能和英国整个国家的国土面积以及文化有关吧。<br>2、我在英国遇到的很多人都很和善有礼貌，在这段时间听的最多的就是 thank you、excuse me，而且其中有一次我坐公交车的时候为了和司机说 thank you 直接从 2 层下来跑到前门说一声 thank you 就下车了，下车才发现这个车是有后门的。包括在牛津还遇到公交车司机帮助骑着代步车的老年人上车。<br>3、在我家那位的指导下，知道了过路口要主动按下路口的按钮并等待红绿灯变绿，知道了我可以随时通过伊丽莎白女王灯，当然还是有很多外国人闯红灯超出中国人的想象，可能也是因为人少吧，不像中国人多，一个人闯红灯后面的人跟着走的话，估计汽车就走不了了。<br>4、在英国旅行交通、住宿和餐饮都相对国内贵一些，而且车票价格根据买的时间早晚也不一样，所以出行要提前计划好并买票，如果有 Young Person Railcard 最好，因为有了它可以节省你 1/3 的交通费。<br>5、住宿的话 Airbnb 相对好一点，大部分时候可以做早餐，甚至房东提供早餐，现在 Airbnb 越来越像酒店了，我在伦敦的几天里住的 Airbnb 全程没见过房东，有问题联系房子里的管家，和酒店的区别就是有了一个厨房可以做饭。当然这个也要看运气，我在牛津住了一晚，房间是房东空出的一间出租的，当天晚上也可以和房东闲聊，第二天早上房东还给我们准备了早餐。<br>6、吃的方面，在外玩的话只要不是特别小的城市，我觉得使用大众点评就够了，一是因为这是中国的产品，里面很多的评价可能对我们更有用一些，也更符合中国人的饮食习惯；另外一方面也是因为太多的吃的地方都被中国人打卡了，一个大众点评就可以搞定。<br>7、在英国的很多城市和公园随处可见小动物，尤其是鸽子和松鼠，而且有很多小动物不怕人的，在大街上一群鸽子等着人投食是很常见的。我们在牛津街头长椅上吃面包的和薯片甚至都有鸽子要飞起来和我们抢着吃了。<br>8、这次旅行很开心，期待下一次可以有时间去英国更多的城市玩。如果美国签证放松的话，也要计划一下美国的西部自驾了，哈哈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年春节没有回家而去了英国，年假加春节假期一起有半个月时间，期间大概有一周时间游览了英国的几个城市。当然，这次出行看似是旅行，实则属于探亲，所以游玩的几个城市也没刻意做任何攻略，全是自然的走走看看，随手拍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhang
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="旅行" scheme="http://CalvinCheung.coding.me/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python 新手的爬虫实战</title>
    <link href="http://CalvinCheung.coding.me/2019/01/19/python-practice/"/>
    <id>http://CalvinCheung.coding.me/2019/01/19/python-practice/</id>
    <published>2019-01-19T13:45:06.000Z</published>
    <updated>2019-01-19T15:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在学完了 <code>Python</code> 基础、网络编程和数据库之后，我使用某 <code>App</code> (某知识付费产品) 进行了爬虫实践，以下是爬虫的具体操作步骤：<br>1、使用 <code>Charles</code> 抓取并解析 <code>API</code> 接口。<br>2、<code>Python</code> 代码编写并进行 <code>API</code> 源数据抓取存入本地数据库。<br>3、解析源数据并使用 <code>Python</code> 程序批量下载其音频文件。<br>4、处理音频对应的文稿数据，按照指定规则生成对应的 <code>PDF</code> 文件。</p><p>其中使用到的第三方库如下：</p><ul><li><code>urllib</code> 网络库</li><li><code>pymysql</code> 数据库</li><li><code>pdfkit</code> 生成 PDF</li></ul><h3 id="1、API-抓取和分析"><a href="#1、API-抓取和分析" class="headerlink" title="1、API 抓取和分析"></a>1、API 抓取和分析</h3><p>使用 <code>Charles</code> 抓取其产品 <code>API</code> 接口，因为现在的 <code>API</code> 大多是 <code>https</code> 类型，所以此处需要配置了一个 <code>Charles CA</code>证书，然后正常抓取并分析了其产品几个主要 <code>API</code>，包括课程分类、课程分类下的课程、课程的内容列表、课程中每节课对应的详情。</p><h3 id="2、Python-代码编写并保存课程数据至数据库"><a href="#2、Python-代码编写并保存课程数据至数据库" class="headerlink" title="2、Python 代码编写并保存课程数据至数据库"></a>2、Python 代码编写并保存课程数据至数据库</h3><p>因为只有在查看单节课程详情时才验证用户身份（查看课程详情需要会员身份），所以我把课程分类数据存入了本地的 <code>.json</code> 文件，通过 <code>Python</code> 程序直接读取对应文件请求课程内容列表等基础数据并存入数据库。<br><a href="https://github.com/CalvinCheungCoder/Python/blob/master/Python_ylyk/ylyk_sourse2.py" target="_blank" rel="external">点此查看此部分代码</a><br>把所有课程基本数据存入到数据库后，通过 <code>Charles</code> 提取出我的个人信息 (我是此 <code>App</code> 的会员用户，可以查看所有内容) 并模拟 <code>App</code> 进行网络请求，把单节课程的源数据请求并以 <code>json</code> 字符串的形式 <code>update</code> 到数据库。然后解析 <code>json</code> 文件提取出课程的音频链接。<br><a href="https://github.com/CalvinCheungCoder/Python/blob/master/Python_ylyk/ylyk_course.py" target="_blank" rel="external">点此查看此部分代码</a> 此处代码删减了我会员身份相关的信息。</p><h3 id="3、批量下载其音频文件"><a href="#3、批量下载其音频文件" class="headerlink" title="3、批量下载其音频文件"></a>3、批量下载其音频文件</h3><p>因为已经拿到了源数据并分析出了产品的音频链接，所以直接按照链接下载并按照指定路径和名称把 <code>mp3</code> 文件保存到本地即可。<br><a href="https://github.com/CalvinCheungCoder/Python/blob/master/Python_ylyk/ylyk_download_audio.py" target="_blank" rel="external">点此查看此部分代码</a></p><h3 id="4、处理文稿数据并生成-PDF-文件"><a href="#4、处理文稿数据并生成-PDF-文件" class="headerlink" title="4、处理文稿数据并生成 PDF 文件"></a>4、处理文稿数据并生成 PDF 文件</h3><p>有了音频文件接下来要处理文稿数据，因为毕竟听音频配合文稿才最合适嘛。因为此产品的文稿数据是分段拼接而成，此处需要根据 <code>App</code> 内的文稿格式分析其 <code>json</code> 结构并按照一定顺序拼接。<br>拼接好文稿后使用 <code>pdfkit</code> 生成对应的 <code>PDF</code> 文件，因为 pdfkit 可以直接解析 <code>HTML</code> 字符串并按照其格式生成 <code>PDF</code>，所以此处我使用了 <code>HTML + CSS</code> 进行简单排版导出到指定路径，按照课程名称生成 <code>PDF</code> 文件，至此数据抓取和下载已经全部完成。<br><a href="https://github.com/CalvinCheungCoder/Python/blob/master/Python_ylyk/ylyk_createPDF.py" target="_blank" rel="external">点此查看此部分代码</a></p><h3 id="5、后记"><a href="#5、后记" class="headerlink" title="5、后记"></a>5、后记</h3><ol><li>在使用我的账户抓取课程详情内容时，因为 <code>API</code> 接口调用会过多，我隐约担心账户会被封，但是我在 10 分钟内连续调用了 2000 余次 API 账号并无任何被封迹象，可见该产品在其安全性设计上存在一些缺陷。</li><li><code>Python</code> 真的很强大，因为我刚开始写 Python 水平还不是很高，但是整个过程下来代码不足 300 行，真的是很简洁。而且 <code>Python</code> 语言下的第三方库很多，比如说 <code>pdfkit</code>，你可以传入一个网页地址生成 <code>PDF</code>，也可以自己编写 <code>HTML</code> 代码使其按照你想要的样式生成丰富的 <code>PDF</code> 文件，不得不说真的很方便，当然类似的库还有很多。</li><li>面对各种各样的网络爬虫的存在，现在的 <code>App</code> 安全性相对还是较弱的，尤其是涉及到商业利益的核心数据，按理说用户读取这些数据必须验证其真实身份并进行读取次数限制。正是因为 App 这样的漏洞存在，像『得到』『喜马拉雅』『樊登读书会』等内容付费 <code>App</code> 中的课程被盗版的才会如此猖獗。</li><li>因为其抓取内容涉及到商业数据，所以此处代码仅展示抓取数据的思路，并没有展示我的个人账户信息，如果有幸被你查看了我的代码，也只能使用该代码获取公开的基础数据。</li><li>因为我有此产品的会员资格，所以此次数据抓取仅做技术实践，不做其他的商业用途，抓取的数据没有在网络上进行传播，我也删除了抓取的全部数据。</li><li>此处仅作一些技术思路的分享和自我记录，如果有侵权行为请及时告知，我会对文章/代码等进行删除处理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学完了 &lt;code&gt;Python&lt;/code&gt; 基础、网络编程和数据库之后，我使用某 &lt;code&gt;App&lt;/code&gt; (某知识付费产品) 进行了爬虫实践，以下是爬虫的具体操作步骤：&lt;br&gt;1、使用 &lt;code&gt;Charles&lt;/code&gt; 抓取并解析 &lt;code&gt;API
      
    
    </summary>
    
      <category term="Python" scheme="http://CalvinCheung.coding.me/categories/Python/"/>
    
    
      <category term="Python" scheme="http://CalvinCheung.coding.me/tags/Python/"/>
    
      <category term="爬虫" scheme="http://CalvinCheung.coding.me/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>2018 年读书总结</title>
    <link href="http://CalvinCheung.coding.me/2018/12/30/2018-readBooks/"/>
    <id>http://CalvinCheung.coding.me/2018/12/30/2018-readBooks/</id>
    <published>2018-12-30T13:34:37.000Z</published>
    <updated>2019-03-02T11:03:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>很庆幸去年底没有给 2018 年的自己定阅读目标，而是随心所欲的阅读。回顾即将过去的 2018 年，完整阅读的书籍有 30 余本，还有部分书籍正在阅读以及阅读中舍弃的就不一一列举了，现在就 2018 年阅读的比较不错的书籍做个总结。<br>其实 2018 年也很遗憾的一点是在阅读中没有及时的记录阅读笔记，并按月或者季度进行阅读整理。2019 年的读书计划依然是随心所欲，但是希望自己能够按月份或者季度进行复盘整理，能够更好的吸收书籍内容。<br>先列下今年的阅读的书籍清单：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2018123001.png" alt="20181203001"></p><h3 id="《精通比特币》-★★★★"><a href="#《精通比特币》-★★★★" class="headerlink" title="《精通比特币》 ★★★★"></a>《精通比特币》 ★★★★</h3><p>这是临近年底阅读的一本书，由于工作涉及到 BitCoin 钱包的开发，但是却没有系统的了解，所以抽时间在电脑上对本书进行了阅读。<br>书中内容从浅入深的讲解了比特币原理、核心、密钥和地址、交易原理、高级交易和脚本、比特币网络、区块链、挖矿和共识等相关内容，很适合对比特币有兴趣了解或者是比特币相关开发者阅读的一本书。</p><h3 id="《美丽新世界》-★★★★★"><a href="#《美丽新世界》-★★★★★" class="headerlink" title="《美丽新世界》 ★★★★★"></a>《美丽新世界》 ★★★★★</h3><p>作者:  [英] 阿道司·赫胥黎的一篇小说，也是反乌托邦小说中一个极具代表的作品了。书中描述了在公元 26 世纪的一个”新世界”，新世界里人们按照等级划分，出生不再依靠母亲，人从出生之前就被赋予了不同的身份，而且不同等级的人们由于被洗脑的原因，都觉得自己所在的等级是最为快乐的人；在新世界里，普通的男女恋爱成为了笑谈，人们以男女约会上床的数量多寡为荣；在新世界里一切井然有序，偶有对现状产生怀疑或叛逆心态者，均被视为不安定因素放逐到边远地区，而我们现在的人类，则成为了边远地区的异类。</p><blockquote><p>如果一个人与众不同，他注定要孤独。他们对与众不同的人非常残忍。</p></blockquote><p>人们为了所谓的美丽新世界放弃很多东西，那确实是一个新世界，但却不美丽。就像茨维格在断头皇后里说的那样：”她那时候还太年轻，不知道所有命运赠送的礼物，早已在暗中标好了价格”。</p><h3 id="《战后日本经济史》-★★★★"><a href="#《战后日本经济史》-★★★★" class="headerlink" title="《战后日本经济史》 ★★★★"></a>《战后日本经济史》 ★★★★</h3><p>书中主要通过作者的经历对日本战后几十年的发展做了总结，内容易读但数据不够翔实，日本战后依靠 1940 体制迅速恢复经济并快速发展，日本经济在这个体制的作用下形成巨大泡沫并迅速破裂，随后陷入了长久的萧条与恢复期。如果说成也 1940 体制，那败也 1940 体制，历史不仅仅是简单的重复上演，但日本战后的经济发展或许对我们有些许启示。</p><h3 id="《伟大的博弈》-★★★★★"><a href="#《伟大的博弈》-★★★★★" class="headerlink" title="《伟大的博弈》 ★★★★★"></a>《伟大的博弈》 ★★★★★</h3><blockquote><p>在《国富论》中，他写道：”同行是冤家，即使是在以娱乐为目的的游戏中，人们也各自心怀鬼胎；而他们相互沟通的目的，往往只是合谋来损害公众的利益，或者设法哄抬价格。”也就是说，自由市场的正常运作需要游戏规则，需要裁判来监督，并强制执行这些规则，否则，市场参与者们就会自己毁掉这个市场，正如一句广为人知的格言所说：”如果社会主义的问题是机制上尚存缺陷的话，那么资本主义的问题就是资本家（的贪得无厌）。”</p></blockquote><p>正是因为华尔街的崛起，使得美国成为世界第一强国。但在华尔街发展过程中，你可以在本书领略到人性的疯狂，对金钱的渴望，而疯狂过后一地鸡毛，又能看出人性之中的阴暗。一次次的疯狂与衰落，历史在不断重演。非常赞的一本纪实书。</p><h3 id="《金钱永不眠》-★★★"><a href="#《金钱永不眠》-★★★" class="headerlink" title="《金钱永不眠》 ★★★"></a>《金钱永不眠》 ★★★</h3><p>本书是唐涯的文章合集，主要讲述资本的历史，以及资本市场的分析，轻松读物。</p><h3 id="《流浪地球》-★★★"><a href="#《流浪地球》-★★★" class="headerlink" title="《流浪地球》 ★★★"></a>《流浪地球》 ★★★</h3><p>刘慈欣的短篇小说，可能是由于篇幅太短，读不出那种很深的科幻味道，当做业余消遣读物来读好了，而且内容短，1 小时内就能读完。据说本书被拍成了电影，在 2019 年大年初一上映，还是很期待电影的内容的。</p><h3 id="《巴比伦富翁的秘密》《巴比伦富翁新解》-★★★★"><a href="#《巴比伦富翁的秘密》《巴比伦富翁新解》-★★★★" class="headerlink" title="《巴比伦富翁的秘密》《巴比伦富翁新解》 ★★★★"></a>《巴比伦富翁的秘密》《巴比伦富翁新解》 ★★★★</h3><p>后者是简七解读的版本，这 2 本书是理财人士初识理财方法，学习开源节流，学习如何管理自己的收入并进行财富增值的入门书。道理都很简单易懂，难在实践。</p><h3 id="《态度》-★★★★★"><a href="#《态度》-★★★★★" class="headerlink" title="《态度》 ★★★★★"></a>《态度》 ★★★★★</h3><p>本书是吴军老师写给女儿的”家书”，全书涉及到人生哲学、观察世界与做事的方法、如何对待金钱、人际关系处理、有效学习以及做人做事的方法。很庆幸在第一时间读了此书，也再一次看到了吴军老师处理家庭关系的睿智。<br>说实话，之所以喜欢读吴军老师的书，是因为他待人做事的宽阔胸怀，处理人际关系的睿智，以及作为长者谦卑的教导年轻人的态度。摘选一些书中内容：</p><blockquote><p>1996年，我刚到巴尔的摩的时候，看到那里的孩子花在读书上的时间都不多，平时好像过得很开心。我问美国人，那些孩子从小不拼命读书，就无法考进一个好大学，将来生活艰苦，怎么办。美国人说，拼命读书能否让将来的生活更好，还是一个未知数，但是快快乐乐地生活18年，这是能够看到的，自己也能够把握；人生能有多少个18年，与其愁眉苦脸地度过少年时光，不如先快快乐乐地过18年。他们的话，有一定的道理，一个乐观的人生态度比什么都重要。</p></blockquote><hr><blockquote><p>我除了有一个乐观的天性，主要在以下4个方面做得还算好。<br>第一，不断地接受教育，与时俱进。学习，获得新知，了解世界的发展本身就是一件幸福快乐的事。因此，我一直提倡学习是一辈子的事。<br>第二，有理想并努力实现自己的愿望。人无理想，就会厌倦当前的生活，快乐也就无从谈起；有理想却不采取行动，不去做，又会失望、苦闷。因此，有理想和身体力行相辅相成，同时具备，就是快乐的源泉。<br>第三，与人相处共事，尽可能互相尊重，互相包容。我对自己的要求是和谐少争，无争是不可能的，做到少争还是有可能的。在一个集体中，不要妄自尊大、看轻他人，这样就容易与人相处，减少矛盾，自然也就容易得到快乐。<br>第四，看透人生。你现在还太年轻，不能体会这一点，也不需要体会。人最终必须看透很多事情，随着年龄的增长，你会体会这一点。<br>你很快就要离家独自上学了，你问我们对你有什么期望，我最期望的就是你在学校里能够过得快乐，相比你的快乐，取得好成绩是次要的。长远来讲，我期望看到你一辈子不论遇到什么事情，都能保持乐观，做一个快乐的人。</p></blockquote><hr><blockquote><p>年轻人在做任何决定之前应该做好准备，三思而行，但是对于想清楚的事情，做起来就不要犹豫。很多事情你在做成之后，回过头来看成功的概率不过5％甚至更低。如果你在做之前就开始算概率，很多事根本不会开始做。年轻人和老年人的一个差别在于，前者很多时候不知艰难，努力去做了，也就做成了，而后者因为有过失败的教训，知道一件事不是那么容易做成，想想做成的可能性，算算成本，还没有开始，就已经放弃了。努力了，至少还有一个希望；放弃了，则永远不可能有希望。</p></blockquote><h3 id="《邓小平时代》-★★★★"><a href="#《邓小平时代》-★★★★" class="headerlink" title="《邓小平时代》 ★★★★"></a>《邓小平时代》 ★★★★</h3><p>一代睿智领导人的心路历程，也是中国近代发展的历史，我读的是简体中文版，部分章节有删减，据说台版和英文版是完整的。<br>以史为鉴，可以知兴替。正是因为邓小平影响了近代中国，使我们能够实现现在的美好生活。但是历史还是需要铭记的，书中也讲述了一些可能现在年轻人不怎么了解的历史，建议每个看到此书的人都能阅读一下。强烈推荐。</p><h3 id="《韭菜的自我修养》-★★★★"><a href="#《韭菜的自我修养》-★★★★" class="headerlink" title="《韭菜的自我修养》 ★★★★"></a>《韭菜的自我修养》 ★★★★</h3><p>在投资市场，可能 99% 的人都是赔钱的。投资市场宛如一个赌局，是一个零和博弈的市场，如果你不想做那个输钱的人，你就必须武装自己的头脑，拥有独立思考、独立判断的能力，唯有此才能在市场中获得一些胜利的果实。<br>本书是李笑来先生对投资的总结与思考，内容不是很多，但却是最干货的内容。比如他说亡羊补牢的“韭菜”才有前途、善于学习、减少冒险、降低交易频率、掌握买入时机、参考少数人的意见但自己做决定等等。</p><blockquote><p>◆ 3 亡羊补牢的“韭菜”才有前途<br>所以，“亡羊补牢”的“韭菜”最应该做的是什么呢？很简单啊：</p><ol><li>还有钱的话，就慢慢补仓；</li><li>钱不够的话，就在场外拼命赚钱。</li></ol></blockquote><hr><blockquote><p>投机者拒绝学习，投资者善于学习。<br>“在牛市尾巴进场”，是绝大多数人的宿命，没啥可抱怨的，又因为是既定事实，所以也没有什么办法去逆转。然而，因为无知进场，又因为无知退场，这是最凄惨的结局。虽然是因为无知进场，但正是因为已经经历了无知的下场，所以玩命地把自己变成一个有知者——这才是明智的选择，不仅明智，这才是强者的选择。<br>做一个强者。这是所有优秀交易者的信仰。也应该是一个“新手”，或者“新韭菜”必须树立的观念，只有这样，将来才不会“依然是一根韭菜”。<br>熊市里除了在场外赚钱补仓之外，还能干什么？学习啊！起码要开始锻炼学习的能力。<br>不知道学什么？接着读下去，认真读，一个字也不要漏掉。反复读，至少你能学会一些你原先不可能理解的思考方式和思考结果。于是，你从此改变了自己的思考方式。思考带来决策，决策带来行动，行动改变命运——这是大实话。</p></blockquote><hr><blockquote><p>喜欢冒险的最终都是“韭菜”<br>想要摆脱“韭菜的宿命”，你必须学会的一个观念是：<br>能不冒险绝不冒险；<br>即便是必须冒险的时候，也要让傻瓜们冒险，自己在一旁通过观察获得经验。<br>获得经验的最直接方法是通过自己的实践获得。然而，在风险这件事儿上，一定要尽早学会观察他人的冒险实践，而不是通过自己的实践。</p></blockquote><h3 id="《后帝国时代》-★★★★"><a href="#《后帝国时代》-★★★★" class="headerlink" title="《后帝国时代》 ★★★★"></a>《后帝国时代》 ★★★★</h3><p>本书是关于苹果公司 CEO Tim Cook 的书，乔布斯在世之时被当做神一般的存在，而他去世以后，接替他的是大众所不熟知的 Tim Cook，究竟他能把苹果公司带领向何方，他是否会按照乔布斯的方法来管理苹果公司？<br>事实上，他是和乔布斯完全不一样的人，正是因为本书我才得以窥见一二。本书通过十几个小故事展示了他是如何领导苹果公司的业务，一步一步按照自己的方法管理苹果公司的。在大众眼中，近几年苹果公司的很多做法让人无法接受，大屏手机、凸起的摄像头、相同的 ID 设计用了好几年、App Pencil 的推出等等，大众认为如果是乔布斯管理下的苹果公司绝不会如此作为。<br>但是乔布斯在临终之时告诉他，要做自己。所以库克按照自己的方法引领苹果公司继续下去，虽有很多大众吐槽的东西，但是苹果公司在他的带领下实现产品销量和利润的提升，前段时间苹果公司市值一度突破 10000 亿美元大关。这一切，和 Tim Cook 的努力有很大关系。<br>如果你对苹果公司有兴趣，对 iPhone 有兴趣，强烈推荐你阅读此书，了解一个不一样的苹果公司。</p><h3 id="《穿过欲望之城》-★★★★"><a href="#《穿过欲望之城》-★★★★" class="headerlink" title="《穿过欲望之城》 ★★★★"></a>《穿过欲望之城》 ★★★★</h3><p>从我们懂事开始，我们似乎就在一直追求一些我们看不到的东西。在家里争取父母的关心与爱护；在读书时，争取获得好成绩，在同学和老师那里留下好印象；在工作中，我们争取更好的工作结果，我们争取领导的赏识；在社会中，我们一步一步追求金钱、权利；年老时，我们追求内心安逸、平和，我们期望儿女孝顺；临终时，我们希望落叶归根。<br>我们这一生，似乎永远在追求的道路上，只是每个人追求的东西不同罢了。本书讲述了一个贫苦的小孩在贫寒的家庭中长大，随着父母的一个决定搬家到大城市，在大城市里他的命运出现重大的转折，在大城市里一切充满了机会，而小男孩的目标就是成为一个有钱人，为了这个目标，他愿意付出一切代价。<br>男孩把握住了每一个机会，命运也眷顾了他。然而随着年龄的增长，他渐渐意识到了自己真正渴望什么……，正如书中的一句话说的那样：”我奔走一生追求金钱，最后才发现我真正渴望的是爱。”<br>或许我们还一直在追求的路上，但是这一本书中多多少少有我们的些许影子。</p><h3 id="《魔鬼经济学》-★★★★"><a href="#《魔鬼经济学》-★★★★" class="headerlink" title="《魔鬼经济学》 ★★★★"></a>《魔鬼经济学》 ★★★★</h3><p>本书一套共 4 本，之前断断续续的阅读过 2 本，今年有机会就把剩余的 2 本读完了。整套书的章节没有太多的前后关系，大家喜欢阅读的可以跳转部分章节进行阅读。不过本书最值得推荐的原因还是作者处理生活中事情的态度和观点。<br>书名虽有经济学，但是全书并没有什么经济学公式。而是先通过许许多多的案例，而后作者对其进行分析、解读，必要时候会有数据的分析，靠这些处理数据的方法，看待事情的角度，给人耳目一新的感觉，也能让我们通过作者的方法改变自己的思维模式，从多维度看待和思考问题。<br>比如：美国某城市的犯罪率下降不是由于政府的法律法规，也不是由于监狱的惩罚措施，而是十几二十年前该州通过的允许堕胎的法案，此法案使得很多贫苦地区的出生率下降，而贫苦地区的孩子又是犯罪的主力，出生率下降就导致了犯罪率下降，只是这个影响出现的时间比较慢而已。<br>又比如毒贩为什么和母亲住一起？恐怖分子的银行账户有什么特点？哪一天适合抢银行？等等，本书都会给你答案，全套书阅读起来诙谐有趣，值得一读。</p><h3 id="《刀锋》-★★★★★"><a href="#《刀锋》-★★★★★" class="headerlink" title="《刀锋》 ★★★★★"></a>《刀锋》 ★★★★★</h3><p>这是我读的毛姆的第一本书，也是感觉很不错的一本书。本书也是毛姆四大长篇小说中的最后一部，小说初稿完成后，他说：”写这本书带给我极大的乐趣，我才不管其他人觉得这本书是好是坏。我终于可以一吐为快，对我而言，这才是最重要的。”<br>正因为此，本书阅读起来才会感觉如此的畅快淋漓。就像豆瓣书友说的那样：”有人说，爱情不一定要有激情，在我看来是胡说八道。所谓没有激情的爱情，根本就不是爱情，而是属于喜欢，体贴、共同的兴趣或是习惯。”<br>推荐大家阅读。</p><h3 id="《优秀的绵羊》-★★★★"><a href="#《优秀的绵羊》-★★★★" class="headerlink" title="《优秀的绵羊》 ★★★★"></a>《优秀的绵羊》 ★★★★</h3><p>如果大学这个系统有问题，如果大学培养的所谓”精英”并不是精英的话，我们又该如何为下一代选择教育方式呢？<br>在本书当中，作者德雷谢维奇历数哈佛、耶鲁、普林斯顿等常春藤学校学生的“数宗罪”：过于自信却输不起；朋友圈同质化，固步自封；思维僵硬，与社会脱节，缺乏“常识性聪明”等，并提出“读藤校远不如读公立大学，学校更重视教育、教学方法也更灵活、更前沿”等观点，<br>他还进一步指出，虽然这些藤校外表上有特色，但在内里，都是“失去了灵魂的地方”。很多在藤校就读的学生没有使命和目标感，自我膨胀、自我中心、自以为是。而相比之下，那些没有这些标签的人，却能在人生道路上攻城掠地，在各方面成就自己。而有一些藤校生一辈子最大的成就，可能只是上过某藤校。<br>反观我们国内现在的教育环境，说实话尤其是看了很多年轻同事小孩子上学的问题，我对整个教育体制最大的感觉就是失望但又不知所措。希望将来对下一代的教育上，我能有更好的方案选择，能够避免把我的他/她培养成一只优秀的绵羊。</p><h3 id="《原则》-★★★★★"><a href="#《原则》-★★★★★" class="headerlink" title="《原则》 ★★★★★"></a>《原则》 ★★★★★</h3><p>本书是桥水基金创始人瑞·达利欧的作品，恐怕也是 2018 年最值得读的一本书了，本书从多角度、立体阐述生活、工作、管理原则。<br>包含21条高原则、139条中原则和365条分原则，涵盖为人处事、公司管理两大方面。此前从未有过的逐一详细解答，配合达利欧多年来的各种实例和感悟。任何人都可以轻松上手实践。用以指导桥水日常管理，是桥水的员工手册，帮助桥水屹立40余年不倒，经受住了现实考验。<br>而我们作为普通人在生活和工作中如何使用这些原则？虽然这些原则并不是每条都对我们适用，但是多少对我们有些许启发和帮助。</p><blockquote><p>我的目标只是让自己正确——我并不关心正确的答案是不是来源于我。所以我学会了让自己保持极度开明的心态，允许其他人指出我可能疏忽的东西。我发现，我能够成功的唯一途径将是：<br>1．找到与我观点不同的最聪明的人，以便自己能够努力理解他们的推理。<br>2．知道自己在什么时候不能有明确的意见，不急于下结论。<br>3．逐步归纳永恒和普适的原则，对其进行测试，将其系统化。<br>4．通过平衡风险来保持较大的回报，并降低下行波动。</p></blockquote><hr><blockquote><p>第二部分 生活原则<br>1.1 做一个超级现实的人<br>1.2 真相（或者更精确地说，对现实的准确理解）是任何良好结果的根本依据<br>1.3 做到头脑极度开放、极度透明、<br>1.4 观察自然，学习现实规律<br>1.5 进化是生命最大的成就和最大的回报<br>1.6 理解自然提供的现实教训<br>1.7 痛苦+反思=进步<br>1.8 考虑后续与再后续的结果<br>1.9 接受结果<br>1.10 从更高的层次俯视机器</p></blockquote><h3 id="《把时间当做朋友》-★★★★"><a href="#《把时间当做朋友》-★★★★" class="headerlink" title="《把时间当做朋友》 ★★★★"></a>《把时间当做朋友》 ★★★★</h3><p>李笑来先生的另一本书，此书出版时间已经很长，但是我却一直未阅读，今年读起来很多内容都颇有感触。<br>比如他书中对坚持的解释，这也成为了我生活中的一部分。很多事情你内心如果把坚持的想法看的太重反而坚持不下来，但是你把一件事情当成理所应当的去做，却能够做的长久。比如今年我学习英语口语、坚持看书等，正是因为我把这些事情当成日常生活的一部分才得以把事情一直做下去。<br>我们如何利用时间，如何对自己的精力进行管理才是最重要的，只有合理利用时间，开启自己的心智，才能把时间当成自己的朋友，在人生之路上才不会后悔。正如木心老先生的那句话：”岁月不饶人，我亦未曾饶过岁月。”</p><h3 id="《穷查理宝典》-★★★★★"><a href="#《穷查理宝典》-★★★★★" class="headerlink" title="《穷查理宝典》 ★★★★★"></a>《穷查理宝典》 ★★★★★</h3><p>本书讲述了巴菲特的合伙人查理·芒格个人事迹和投资哲学。本书给我最大的感受就是每句话都想划线，因为查理太睿智了，让人不由得想成为他这样的人，博学、爱读书、专注、理性、靠谱、睿智等等品德让人叹服。</p><blockquote><p>世俗智慧告诉我们，循规蹈矩的失败比离经叛道的成功更能带来好名声。 ——约翰·梅纳德·凯恩斯<br>请爱护你的声誉，像珍惜你最贵重的珠宝那样——因为信誉就像火焰，点着之后，你可以轻松地让它燃烧，可是一旦把它扑灭，你必须很费力才能再次点燃它。获取好声誉的办法是努力成为你想要成为的人。——苏格拉底</p></blockquote><p>在遗传因素的作用之下，刚孵出来的小鹅在破壳而出后将会“热爱”并跟随第一个对它和善的生物，那几乎总是它的母亲。但是，如果小鹅孵出来那一刻，出现的并不是母鹅，而是一个人，那么小鹅将会“热爱”并跟随这个人，把他当作自己的母亲。<br>避免因为过去的成功而做蠢事的正确对策是：<br>（1）谨慎地审视以往的每次成功，找出这些成功里面的偶然因素，以免受这些因素误导，从而夸大了计划中的新行动取得成功的概率；<br>（2）看看新的行动将会遇到哪些在以往的成功经验中没有出现的危险因素。<br>憎恨和讨厌也会造成由简单联想引起的认知错误。在企业界，我常常看到人们贬低他们讨厌的竞争对手的能力和品德。这是一种危险的做法，通常不易察觉，因为它是发生在潜意识层面的。<br>自视过高的人比比皆是。这种人会错误地高估自己，就好像瑞典有90%的司机都认为他们的驾驶技术在平均水平之上。这种误评也适用于人们的主要“私人物品”。人们通常会过度称赞自己的配偶。人们通常不会客观地看待自己的孩子，而是会给出过高的评价。甚至人们的细小私人物品也一般会得到过度的称赞。人们一旦拥有某件物品之后，对该物品的价值评估就会比他们尚未拥有该物品之前对其的价值评估要高。这种过度高估自己的私人物品的现象在心理学里面有个名称：“禀赋效应”。人们作出决定之后，就会觉得自己的决定很好，甚至比没作出这种决定之前所认为的还要好。</p><p>2018 年即将过去，希望在 2019 年里能够有时间阅读更多好书。也希望明年不是做年终阅读总结了，而是分散到每个月或者每个季度里去。anyway，Happy New Year！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很庆幸去年底没有给 2018 年的自己定阅读目标，而是随心所欲的阅读。回顾即将过去的 2018 年，完整阅读的书籍有 30 余本，还有部分书籍正在阅读以及阅读中舍弃的就不一一列举了，现在就 2018 年阅读的比较不错的书籍做个总结。&lt;br&gt;其实 2018 年也很遗憾的一点是
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="读书笔记" scheme="http://CalvinCheung.coding.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 Google Cloud 搭建 BBR+SS/SSR 科学上网</title>
    <link href="http://CalvinCheung.coding.me/2018/12/23/create-ss-using-google-cloud/"/>
    <id>http://CalvinCheung.coding.me/2018/12/23/create-ss-using-google-cloud/</id>
    <published>2018-12-23T12:05:09.000Z</published>
    <updated>2018-12-23T12:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期又折腾了几次科学上网，每次设置都需要上网寻找教程，看到了一篇还不错的，索性转载并根据自己的情况稍作修改自留。<a href="https://cyhour.com/520/" target="_blank" rel="external">原文链接：小试 Google Cloud 搭建 BBR+S$ 科学上网</a>，如有侵权请告知，我会做删除处理。</p><p>Google Cloud 其实就是个 VPS，VPS 能干的它都能实现。Google Cloud 赠送 300 刀可以使用 1 年，也就是说如无意外，我们可以免费使用 1 年速度还不错的 SS/SSR 科学上网。</p><p><a href="https://console.cloud.google.com/freetrial" target="_blank" rel="external">Google Cloud 试用地址</a>，自备 Visa 信用卡。申请不成功自行放狗或者找度娘。</p><h3 id="1、计算引擎中创建VM实例"><a href="#1、计算引擎中创建VM实例" class="headerlink" title="1、计算引擎中创建VM实例"></a>1、计算引擎中创建VM实例</h3><p>选个乞丐配置就好。<br><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/ssr1.png" alt="1"></p><h3 id="2、申请保留静态-IP"><a href="#2、申请保留静态-IP" class="headerlink" title="2、申请保留静态 IP"></a>2、申请保留静态 IP</h3><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/ssr2.png" alt="2"></p><h3 id="3、修改防火墙"><a href="#3、修改防火墙" class="headerlink" title="3、修改防火墙"></a>3、修改防火墙</h3><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/ssr3.png" alt="3"></p><h3 id="4、安装-BBR-内核"><a href="#4、安装-BBR-内核" class="headerlink" title="4、安装 BBR 内核"></a>4、安装 BBR 内核</h3><p>SSH 登录，sudo -i 切换到 root 用户。<a href="https://teddysun.com/489.html" target="_blank" rel="external">方法源自秋水逸冰</a></p><p>运行以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</div><div class="line">chmod +x bbr.sh</div><div class="line">./bbr.sh</div></pre></td></tr></table></figure><p>安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启。</p><p>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">uname -r</div></pre></td></tr></table></figure><p>查看内核版本，含有 4.11 就表示 OK 了</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sysctl net.ipv4.tcp_available_congestion_control</div></pre></td></tr></table></figure><p>返回值一般为：<br>net.ipv4.tcp_available_congestion_control = bbr cubic reno</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sysctl net.ipv4.tcp_congestion_control</div></pre></td></tr></table></figure><p>返回值一般为：<br>net.ipv4.tcp_congestion_control = bbr</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sysctl net.core.default_qdisc</div></pre></td></tr></table></figure><p>返回值一般为：<br>net.core.default_qdisc = fq</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">lsmod | grep bbr</div></pre></td></tr></table></figure><p>返回值有 tcp_bbr 模块即说明bbr已启动。</p><h3 id="5、安装-SS-SSR"><a href="#5、安装-SS-SSR" class="headerlink" title="5、安装 SS/SSR"></a>5、安装 SS/SSR</h3><p>这里使用秋水逸冰提供的一键脚本，脚本代码如下，<a href="https://teddysun.com/486.html" target="_blank" rel="external">脚本原文链接：Shadowsocks 一键安装脚本（四合一）</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo -i</div><div class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</div><div class="line">chmod +x shadowsocks-all.sh</div><div class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</div></pre></td></tr></table></figure><p>运行过程中关于 SS/SSR 的配置不明白的地方，请查看 <a href="https://github.com/Ehco1996/django-sspanel/wiki/ShadowsocksR-%E6%8E%A8%E8%8D%90%E5%8D%8F%E8%AE%AE%E6%B7%B7%E6%B7%86%E8%AE%BE%E7%BD%AE" target="_blank" rel="external">此篇文章</a></p><p>配置完成后效果如下：<br><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/ssr4.png" alt="4"></p><h3 id="6、油管速度"><a href="#6、油管速度" class="headerlink" title="6、油管速度"></a>6、油管速度</h3><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/ss-youtube.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近期又折腾了几次科学上网，每次设置都需要上网寻找教程，看到了一篇还不错的，索性转载并根据自己的情况稍作修改自留。&lt;a href=&quot;https://cyhour.com/520/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接：小试 Google C
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="科学上网" scheme="http://CalvinCheung.coding.me/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 上使用 pyenv 安装管理多版本 Python</title>
    <link href="http://CalvinCheung.coding.me/2018/04/01/install-python-on-mac/"/>
    <id>http://CalvinCheung.coding.me/2018/04/01/install-python-on-mac/</id>
    <published>2018-04-01T08:27:10.000Z</published>
    <updated>2019-03-02T11:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先通过<code>homebrew</code>安装<code>pyenv</code>，之后的所有<code>Python</code>安装和管理通过<code>pyenv</code>进行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ brew install pyenv</div></pre></td></tr></table></figure><p><code>pyenv</code>安装完以后，就可以选择性的进行<code>Python</code>环境安装了。下面已安装<code>Python2.7</code>为例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pyenv install 2.7.5</div></pre></td></tr></table></figure><p>此外，你还可以通过<code>pyenv</code>查看目前系统中已经安装过的<code>Python</code>版本</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pyenv versions</div></pre></td></tr></table></figure><p>如果需要在不同版本的<code>Python</code>间进行切换的话，使用以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pyenv global 3.3.1</div></pre></td></tr></table></figure><p>当然，你也可以让版本切换只对当前目录生效</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pyenv local 2.7.5</div></pre></td></tr></table></figure><p>参考链接：<a href="https://stackoverflow.com/questions/18671253/how-can-i-use-homebrew-to-install-both-python-2-and-3-on-mac" target="_blank" rel="external">How can I use Homebrew to install both Python 2 and 3 on Mac?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先通过&lt;code&gt;homebrew&lt;/code&gt;安装&lt;code&gt;pyenv&lt;/code&gt;，之后的所有&lt;code&gt;Python&lt;/code&gt;安装和管理通过&lt;code&gt;pyenv&lt;/code&gt;进行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="DevTips" scheme="http://CalvinCheung.coding.me/categories/DevTips/"/>
    
    
      <category term="Python" scheme="http://CalvinCheung.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>再见，我的2017</title>
    <link href="http://CalvinCheung.coding.me/2018/01/01/goodbye2017/"/>
    <id>http://CalvinCheung.coding.me/2018/01/01/goodbye2017/</id>
    <published>2018-01-01T12:51:02.000Z</published>
    <updated>2019-03-02T11:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017 于我是极其特别的一年，这一年，我24岁。可能人就是这样，越是到一个敏感的时间节点，比如18岁、24岁、30岁等，越能让人变得敏感和深刻。这让我想起王小波在他的《黄金时代》中的一段话：</p><blockquote><p>那一天我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p></blockquote><p>只是，我没有想到的是，我在 24 岁才开始理解生活是一个缓慢受锤的过程。</p><h3 id="关于健康"><a href="#关于健康" class="headerlink" title="关于健康"></a>关于健康</h3><p>年后由于牙齿出现问题，去医院检查才发现已经很严重了，其实在此之前的大约2-3年时间里，我一直忽略了它的存在。牙疼的时候忍一忍就过去了，或者找找网上的偏方止痛一下。但是，随着时间的推移，到今年年初时，这颗牙齿基本已经不复存在了，检查过后经过考虑，还是决定对其进行治疗。</p><p>就这样，在今年大概 3 月份开始，陆陆续续治疗了半年多的时间，期间忍受了多次的难以言说的痛苦，花费了一笔不小的开支，一颗牙齿总算治好了，只是从此以后跟随我的再也不是原本属于我的那一颗牙齿。时间就是这样子，你对它怎样，它也对你怎样。</p><p>牙齿治疗好以后，我对待牙齿就变得很小心了。早晚刷牙，掌握刷牙技巧，漱口水，牙线，定期洗牙等，能用的坚决用上，时刻保持牙齿清洁，保护牙齿健康。人不都是这样吗？很多事情只有自己经历一次，才会记得那么刻骨铭心。而且，今年也在住处附近办了一张2年期的健身卡，虽然后来没怎么坚持，但是在 2018 年，一定要让自己坚持锻炼起来，毕竟身体才是革命的本钱啊。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>今年上半年，对自己工作的环境一直不太满意，但是又感觉没有做好跳槽的准备，一直在公司待着。不过期间也做了一些事情，比如把之前的博客废弃了，迁移到了目前使用的这个，也陆陆续续写了几十篇文章，虽然文章的深度还不够，但总归是一个很好的开始。也在此期间帮助同事做了一款 App，帮助他把博客内容搬到了手机上，而且 App 的整体设计都是我来的，也加入了一些还算好玩的功能，也算是工作上的一点收获吧。</p><p>下半年的时间里，由于之前的公司运营不下去，团队只好解散。于是，开始找工作之旅。还好在很快的时间里就确定了一家公司，初入公司后不久我也写了一篇博客记录工作的情况，可以参考 <a href="https://www.zhangdinghao.cn/2017/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E8%BF%91%E5%86%B5/" target="_blank" rel="external">记录一下近况 - DHTalk | DHTalk’s Blog</a>。</p><p>让我感觉比较幸运的是，选择了这个 offer 可能算是我 2017 年做的比较不错的一个决定了。首先工作的氛围很好，公司主要业务是区块链技术方向，又因为自己加入时人员不是很多，所以前期开发的产品让自己掌握了很多区块链的技术，也完成了产品初期很多关于区块链技术的开发工作，对我来说，这是一个巨大的挑战也是一个自我提升的时间点。</p><p>在 11 月开始，公司进入迅速发展的时期，人员迅速增加，产品功能也变得越来越多，所幸的是，来了很多很棒的同事，大家在一起开发产品配合默契，也使得我在他们身上可以学到很多更新鲜的东西。</p><p>新的一年来临，希望新的一年自己能在工作中有更多的进步，不管是技术上还是在团队的配合沟通上。毕竟，技术扎实是根本，也是自己核心竞争力的体现；而团队配合、沟通也会是自己的加分项，我相信良好的沟通技巧肯定能提升大家的效率，节约大家的时间。只有这样，团队才得以有可能开发出更好、更棒的产品。</p><h3 id="关于阅读、学习与时间管理"><a href="#关于阅读、学习与时间管理" class="headerlink" title="关于阅读、学习与时间管理"></a>关于阅读、学习与时间管理</h3><p>今年的阅读情况稍微比去年有所好转，但是整体来说自己还是不太满意。全年阅读书籍 26 本，再加上阮一峰老师未出版的 2 本新书，其中技术书籍占比很少，而且整体来说阅读的深度还是不够，没有能深入的对书籍内容进行领悟和掌握，这也是今年阅读的一个缺憾，希望 2018 年自己能弥补这方面的欠缺。具体的读书总结，可以参考此篇博客 <a href="https://www.zhangdinghao.cn/2017/12/30/2017-readBooks/" target="_blank" rel="external">2017 年读书总结 - DHTalk | DHTalk’s Blog</a></p><p>学习方面，技术方面有些许提升，也在博客对之前很多的技术内容进行了填补，但是整体而言对自己非常不满意，Python 自学了一部分后就放弃了，Swift 方面也只是读书的时候进行了一些 coding。今年还参加了5门的自学考试，但是由于自己疏于学习和复习，只在考试前临时抱佛脚，导致5门的考试只通过了1门，虽然这些都是自己心知肚明的东西，但是现在回想起来，还是对自己学习方面感到深深的不满。</p><p>之所以阅读、学习都让自己没有达到预期的目标，后来我发现是自己的时间管理方面出现了问题。由于没有翔实的学习与阅读计划，导致了学习与阅读效率的低下，在临近年尾的3个月时间里，我对自己的时间进行了一些合理的安排，发现效率很高，今年读书的很大一部分是在年尾的几个月完成的。其实，在做 2017 年计划时，自己也对目标进行了拆分，但是由于时间管理的问题，导致今年的计划完成度很低，这也是 2018 年要努力克服的问题。</p><p>今年也是在得到 App 学习时间比较长的一年，2016 年底接触到了得到，今年一年的时间里在得到听了将近 1000 小时音频，订阅了 4 个专栏。但是，还是时间管理的问题，导致学习的效率和收获都很低下。当到做总结的时候才发现，一切的问题还是由于自己内心太过浮躁，没有能静心总结和学习。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>今年购入了几个新的电子设备，beats X 耳机、iPad Pro 10.5、Smartisan T1、iPhone 8 Plus、iPhone SE等，也在一定程度上提升了自己的生活幸福度。</p><p>今年也和她的关系有了更深的进展，大家互相见了双方父母，定了亲，不出意外，2018 年上半年将是结婚的时间，希望我们能在未来的生活道路上越走越好。</p><p>今年理财方面算是自己的一个败笔，下半年遭遇了几个很不幸的事件，虽然结果都很不好，但是也算是让自己对人生有了更多、更深刻的理解，虽然也心有不甘，但是很多坏的事情还是越年轻体验越好，也希望自己能在未来心理更轻大，这也是为什么说，生活就是个缓慢受锤的过程，而我到 24 岁才开始真正的理解它。</p><h3 id="关于-2018"><a href="#关于-2018" class="headerlink" title="关于 2018"></a>关于 2018</h3><p>不管过去的一年经历了什么，过去的总归要过去，或许有一些收获，有一些失去，但是唯有在失去和收获中更好的总结经验，才能使得未来的生活过成自己想要的样子。对于2017，过去的就不再遗憾，失去的看淡些，得到的也很满意。对于 2018，希望自己能在以下几个方面做好</p><ol><li>阅读书籍能够更深入，读书总结不可少</li><li>技术方面要提升，总结，阅读至少4本书籍</li><li>做好自己的时间管理，提升工作和学习效率</li><li>自学考试要做好计划，争取今年考过8-10门课程</li><li>英语口语要提升，今年8-9月份能够掌握基础的口语对话</li><li>理财方面总结 2017 年教训，18 年能够平稳安全的提升个人财务水平</li></ol><p>2017年，再见。2018年，继续努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017 于我是极其特别的一年，这一年，我24岁。可能人就是这样，越是到一个敏感的时间节点，比如18岁、24岁、30岁等，越能让人变得敏感和深刻。这让我想起王小波在他的《黄金时代》中的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;那一天我二十一岁，在我一生的黄金时代，我
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="年终总结" scheme="http://CalvinCheung.coding.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>2017 年读书总结</title>
    <link href="http://CalvinCheung.coding.me/2017/12/30/2017-readBooks/"/>
    <id>http://CalvinCheung.coding.me/2017/12/30/2017-readBooks/</id>
    <published>2017-12-30T10:14:57.000Z</published>
    <updated>2019-03-02T11:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>即将过去的 2017 年里读了 26 本书，由于种种原因，没有完成年初的每周阅读一本书的目标。在做读书总结时，我也在问自己每周阅读一本书是否真的有必要？自己消化和吸收的又有多少？于是，做完今年的阅读总结，2018 年阅读的计划，随心而定，根据自己的时间安排和喜好来读。</p><p>今年读书类目比较杂，有小说、工具类、传记、人文等，还有阮一峰老师未出版的2本书，大概按照时间顺序对每本书进行一下复盘与回顾，也能避免未来阅读时的选书错误，为 2018 年更好、更深层次的阅读打下基础。</p><p>先列下今年的阅读的书籍清单：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20171230151463671535006.png" alt="20171230151463671535006.png"></p><h4 id="《成为乔布斯》"><a href="#《成为乔布斯》" class="headerlink" title="《成为乔布斯》"></a>《成为乔布斯》</h4><p>绝对的5分好评，全本能够很好的了解乔布斯不为人们所熟悉的一面。比如乔布斯如何被自己招来的 CEO 赶出苹果；在离开苹果的那些岁月里，乔布斯的创业历程并不美好，但是他被皮克斯工作室所影响，皮克斯教会了乔布斯成长；乔布斯又是如何重返苹果后带领苹果起死回生。</p><p>这一系列的故事奠定了苹果发展的基础，这也是乔布斯能够被人们所熟知的原因。如果要有一段话来推荐这本书的话，我会选择苹果的一则广告语，也是本书提及到的部分，★★★★★ 推荐</p><blockquote><p>向那些疯狂的家伙们致敬，他们特立独行，他们桀骜不驯，他们惹是生非，他们格格不入。<br>他们用与众不同的眼光看待事物，他们不喜欢墨守成规，他们也不愿安于现状。你可以赞美他们，引用他们，反对他们，质疑他们，颂扬或是诋毁他们。<br>但唯独不能漠视他们。因为他们改变了事物。他们发明，他们想象，他们治愈，他们探索，他们创造，他们启迪，他们推动人类向前发展。<br>也许，他们已经疯了。<br>你能盯着白纸，就看到美妙的画作么？你能静静坐着，就听见美妙的歌曲么？你能凝视火星，就想到神奇的太空轮么？<br>我们为这些家伙制造良“机”。<br>或许他们是别人眼里的疯子，但他们却是我们眼中的天才。因为只有那些疯狂到以为自己能够改变世界的人，才能真正地改变世界。</p></blockquote><h4 id="《iOS动画–核心技术与案例实战》"><a href="#《iOS动画–核心技术与案例实战》" class="headerlink" title="《iOS动画–核心技术与案例实战》"></a>《iOS动画–核心技术与案例实战》</h4><p>一本很不错的关于 iOS 动画的书籍，是用 Swift 语言编写的，全书分为 4 个部分对 iOS 动画做了深入的讲解，还附带了实例代码。★★★★ 推荐</p><h4 id="《东方快车谋杀案》《罗杰疑案》"><a href="#《东方快车谋杀案》《罗杰疑案》" class="headerlink" title="《东方快车谋杀案》《罗杰疑案》"></a>《东方快车谋杀案》《罗杰疑案》</h4><p>1、一场突如其来的大雪，一列特殊的乘客搭乘的东方快车，午夜出现了一场谋杀案，一个美国人死在了他的包厢里，被刺了十二刀，可他包厢的门却是反锁的。</p><p>大侦探波洛随即进行了侦查并对车厢内人员进行逐一问询，案情扑簌迷离，情节构思巧妙，可以满足你对侦探小说的全部幻想，最终的结果是出人意料的。车厢内的每个人都是凶手，除了波洛。</p><p>结局的最后让人不禁发问，究竟什么是正义？谁又有权利来确保正义？今年，根据本书改编的电影也上映了，拍的也很不错。★★★★★ 推荐</p><p>2、今年读的阿婆的第二本书，代入感很强，推理过程层层推进，当你跟随作者进行推理时，忽然发觉原来这才是结局。这也是我第一次阅读这类写作手法的书。★★★★★ 推荐</p><h4 id="《白夜行》"><a href="#《白夜行》" class="headerlink" title="《白夜行》"></a>《白夜行》</h4><p>东野圭吾的书不同于阿加莎，如果你非要从文字中读出一个所以然来，恐怕要让你失望了。本书被问及最多的问题莫过于以下几个：</p><ol><li>雪穗爱亮司吗？</li><li>亮司爱雪穗吗？</li><li>雪穗爱一成吗？</li><li>雪穗出于什么原因要加害江利子？</li><li>亮司是否付出了太多而雪穗是否在利用亮司？</li><li>雪穗和亮司想要的是什么？</li></ol><p>或许每个人都有不同的理解，只有深入阅读才能给自己一个满意的答案。★★★★ 推荐</p><p>书中金句：</p><blockquote><p>“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吧？我从来就没有太阳，所以不怕失去。”<br>“代替太阳的东西是什么呢？”<br>“你说呢？也许夏美以后会有明白的一天。”说着，雪穗朝着前方调整坐姿，“好了，我们走吧。”</p></blockquote><h4 id="《黑客与画家》"><a href="#《黑客与画家》" class="headerlink" title="《黑客与画家》"></a>《黑客与画家》</h4><p>技术人员都会推荐阅读的一本书。★★★★★ 推荐</p><h4 id="《经济学通识》《小岛经济学》"><a href="#《经济学通识》《小岛经济学》" class="headerlink" title="《经济学通识》《小岛经济学》"></a>《经济学通识》《小岛经济学》</h4><p>《经济学通识》是今年订阅了薛兆丰的北大经济学课专栏后阅读的，配合专栏文章读此书，让人对这个世界的很多事情有了更多层面，更深层次的认识。《小岛经济学》是后续发现，读了一遍，属于经济学入门读物，书中也有大量插画和形象的比喻，能够让经济学小白很好的入门。或许这就是经济学的神奇之处，你可能并不打算成为一个经济学家，但却有必要掌握经济学的思考方法。 ★★★★★ 推荐</p><h4 id="《了不起的盖茨比》"><a href="#《了不起的盖茨比》" class="headerlink" title="《了不起的盖茨比》"></a>《了不起的盖茨比》</h4><p>在没看过得到解读后，只是单纯的当成一本小说来读，经过得到解读，又对本书有了更深层次的了解。★★★★ 推荐</p><h4 id="《Producter-让产品从0到1》"><a href="#《Producter-让产品从0到1》" class="headerlink" title="《Producter 让产品从0到1》"></a>《Producter 让产品从0到1》</h4><p>1992 年作者周楷雯的书，全书讲解了他的 小记 开发历程，全书包含设计、编程、改进、营销很多方面，对技术人员或者是产品设计师都是很不错的书籍，使读者能够了解一款产品诞生与发展的台前幕后所有工作。 ★★★★★ 推荐</p><h4 id="《浪潮之巅全2册》"><a href="#《浪潮之巅全2册》" class="headerlink" title="《浪潮之巅全2册》"></a>《浪潮之巅全2册》</h4><p>简述了很多科技公司的历史以及成功和失败的教训，虽然有些“马后炮”的意味，不过能从这些高科技公司的发展中总结出一套经验和教训来也是值得一读的。尤其是互联网或者 IT 从业者应该读一下，或许可以在以后借鉴反思，避免犯错。★★★★ 推荐</p><h4 id="《硅谷革命：成就苹果公司的疯狂往事》"><a href="#《硅谷革命：成就苹果公司的疯狂往事》" class="headerlink" title="《硅谷革命：成就苹果公司的疯狂往事》"></a>《硅谷革命：成就苹果公司的疯狂往事》</h4><p>今年读过的为数不多的好书之一，全书讲述了苹果公司开发 Macintosh 的历史，关于团队，关于苹果，关于乔布斯，本书都能让你从不同的视角对其有更多的了解。★★★★★ 推荐 </p><p>附 <a href="https://www.zhangdinghao.cn/2017/09/25/readNote-Apple/" target="_blank" rel="external">读书笔记 -《硅谷革命：成就苹果公司的疯狂往事》</a></p><h4 id="《我们的后人类未来》"><a href="#《我们的后人类未来》" class="headerlink" title="《我们的后人类未来》"></a>《我们的后人类未来》</h4><p>第一次读福山的书，感觉一般了，人类伦理和技术进步有问题存在，但在本书中更多的是流水账，文人式的忧虑较多。不做推荐。</p><h4 id="《艾伦图灵传》"><a href="#《艾伦图灵传》" class="headerlink" title="《艾伦图灵传》"></a>《艾伦图灵传》</h4><p>图灵研究思维，可思维却是那样神秘，这位解密大师，最终败给了自己内心的谜。所谓道可道，非常道，尽管图灵没有这种哲学家的超脱，但他的生命实在是不可言说。他本想张口，却哑口失言。推荐技术人员阅读。</p><h4 id="《爆裂-未来社会的9大生存原则》"><a href="#《爆裂-未来社会的9大生存原则》" class="headerlink" title="《爆裂:未来社会的9大生存原则》"></a>《爆裂:未来社会的9大生存原则》</h4><p>九大原则标题起的很好，但是每章的例子真的不怎么好，论点不错，但是论据很多方面不对题，罗胖还在极力推荐，简直就是在打脸。稍微读书量多点的人，看看目录，自己根据目录做个总结，也算自我的一点总结和认知提升了。本人读完觉得一般，不做过多推荐。</p><h4 id="《深度工作》《刻意练习》"><a href="#《深度工作》《刻意练习》" class="headerlink" title="《深度工作》《刻意练习》"></a>《深度工作》《刻意练习》</h4><p>《深度工作》全书分为了2大部分，深度工作的理论和实践。作者给出了如何深度工作的方法，也列举了深度工作的局限性以及深度工作的一些原则。作者自己本人也是深度学习的受益者，关于如何去深度工作，如何学习深度工作，让自己的时间让有效利用，提高效率，这本书值得一读。</p><p>《刻意练习》全书列举了很多天才的案例，分析了其成功的原因，发现没有人天生就是天才，长久有效的刻意练习才是取得成绩，获得成功的关键。有效的练习，及时的反馈机制，牛人的指导，三大关键步骤更能帮助你更快成长，获得成功。</p><h4 id="《灰犀牛》"><a href="#《灰犀牛》" class="headerlink" title="《灰犀牛》"></a>《灰犀牛》</h4><p>看到豆瓣6分的评分我也心安了，整体感觉书的内容一般。一个概念竟然能拼凑出来这么多字，也是服了。</p><h4 id="《小顾聊绘画全2册》"><a href="#《小顾聊绘画全2册》" class="headerlink" title="《小顾聊绘画全2册》"></a>《小顾聊绘画全2册》</h4><p>艺术史简明入门书，和严伯钧的西方艺术史专栏差不多，不过这2本书，内容更轻快。</p><h4 id="《软技能-代码之外的生存指南》《编写可读代码的艺术》"><a href="#《软技能-代码之外的生存指南》《编写可读代码的艺术》" class="headerlink" title="《软技能:代码之外的生存指南》《编写可读代码的艺术》"></a>《软技能:代码之外的生存指南》《编写可读代码的艺术》</h4><p>《软技能:代码之外的生存指南》，作者没有从编程入手，而是涉及到了职业规划，个人影响力提升，学习，理财，健身等各个方面。章节很多，但是每个章节内容很少，也就没有办法进行深入表述，不过很多看似浅显的道理还是需要长时间去实践才能变成自己的收获。总之，很多程序员不善于表达，理财，学习，也没注意过健身，可能只是在重复造轮子，码代码，本书对类似我们这样的程序员还是有很多的帮助的。</p><p>《编写可读代码的艺术》，怎么写出简洁易懂的代码，如何注释等。本书都给出了不错的实例和说明。很不错的一本书。</p><h4 id="《未来简史》"><a href="#《未来简史》" class="headerlink" title="《未来简史》"></a>《未来简史》</h4><p>年初阅读本书还颇有感触，对作者的一些观点也没有很详细的理解和分辨的能力。待到今年年末，再观察书中的对未来的一些设想等感觉太过悲观，我认为数据不应该成功未来主宰整个社会的力量。但是，由于罗胖的推荐，加上上一本书《人类简史》的热度，今年火一把也没办法了，至少书中关于人类过去、人为主义等都是很不错的，有很多不错的观点和认知。</p><h4 id="《高手》"><a href="#《高手》" class="headerlink" title="《高手》"></a>《高手》</h4><p>精英日课第一季的文章节选，读完以后还是有很多收获的。比如承认运气的存在可能让你更受欢迎，如何决策，如何成为有智识的人，高手和普通人有什么区别，以及如何从一个更加长远和宏观的视角来看待现在。第二季现在每天都在听，可能对很多人觉得书里的内容很杂乱，但是每章都有新思想。推荐阅读。照抄书中几个不错的段落分享：</p><blockquote><p>听说一两条负面消息就对世界绝望了，那是无知。认为什么信息都没有意义，那是麻木。知道什么重要什么不重要，该信什么不该信什么，才能对世界有个 “educated guess”</p><p>— 高手 P148</p></blockquote><hr><blockquote><p>三个方面考察一个人的智慧水平<br>1、智识上的谦逊—我知道我需要更多的信息，才能合理评估这件事，我知道未来可能还有不确定性。<br>2、超越自我—我知道我身在这个事件当中可能会当局者迷，如果能从旁观者的视角看问题，也许更好。<br>3、考虑他人的观点，达成妥协—我知道不同观点的利弊，能理解这个事件的参与各方的想法和立场。我不仅仅考虑自己的利益，也考虑跟别人的关系。</p><p>谦逊谨慎，旁观者清，达成妥协，这些都是能让我们生活的更好的品质。能在日常生活中经常做到这三点，就是有智慧的人。</p><p>— 高手 P158</p></blockquote><hr><blockquote><p>【三个智慧】</p><p>我们希望每一天都活在当下，可是从数学的角度来说，你预期停留的时间越长，探索新事物的价值就越高，基廷斯指数也就越高。</p><p>如果我们把期限设定为人的一生，这就意味着年轻人应该多探索，到了后期就要专注于收获。</p><p>因此，对于理性的人来说，要想过好这一生，意味着三件事。</p><p>1、年青时代要大胆探索。<br>2、随着年龄的增长，要学会慢慢利用已有的信息，专注于收获。<br>3、在慢慢变老的过程中，我们的生活其实是越来越好的。</p><p>— 高手 P170</p></blockquote><hr><blockquote><p>如果参与游戏的各方都是”老司机”—每个人都非常聪明，谁也糊弄不了谁，那么游戏就会达到一个各方都满意，或者各方都无奈的局面，任何一方想要采取一个什么行动让自己的局面比现在更好都不可能了，这个局面就叫「纳什均衡」。</p><p>— 高手P182</p></blockquote><hr><blockquote><p>给自己讲一个好故事，找到工作和生活的意义，保持乐观的精神，这是能坚持下来的前提条件。然后，你再把大目标分解成为各种小任务，把每个任务都游戏化，随时奖励自己，获得掌控感，用一个个小胜利慢慢积累进步，这就是通往成功之路。</p><p>— 高手P217</p></blockquote><hr><blockquote><p>WOOP方法</p><p>1、Wish。你想要干什么，比如你想要一个好工作，想到 Google 工作。<br>2、Outcome。把结果具体化，比如去 Google，最理想的职位是资深工程师。<br>3、Obstacle。这是面对现实的一步，看看现在距离这个结果有什么障碍。如果你现在的技术水平已经很厉害了，那么你的障碍就是让 Google 的人知道你。但如果你现在什么技术都没有，那么你的障碍就会很大。<br>4、Plan。制定计划，解决各种障碍。</p><p>— 高手P221</p></blockquote><h4 id="《枪炮、病菌与钢铁》"><a href="#《枪炮、病菌与钢铁》" class="headerlink" title="《枪炮、病菌与钢铁》"></a>《枪炮、病菌与钢铁》</h4><p>这是讲述人类社会发展的另一种解释的书，作者的观点也很新颖，全书基本上属于人类的一部进化史了。资料很详实，文字严谨，观点明确，脉络清晰。推论出人类社会的发展以及现在世界格局的形成，可谓是醍醐灌顶。之所以对这本书有那么多好感，对作者的观点比较认同，因为本人就是环境决定论的最大感知者之一。5星力荐。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>整体来说 2017 年的阅读计划将将及格，往年没有做读书总结的习惯，第一年做这个才发现很多书籍阅读的还是不够深入，对书籍的了解还不够深入。所以，2018 的阅读计划就不在数量上做任何限制了，主要目标是尽可能的利用时间读好书，深度阅读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;即将过去的 2017 年里读了 26 本书，由于种种原因，没有完成年初的每周阅读一本书的目标。在做读书总结时，我也在问自己每周阅读一本书是否真的有必要？自己消化和吸收的又有多少？于是，做完今年的阅读总结，2018 年阅读的计划，随心而定，根据自己的时间安排和喜好来读。&lt;/p
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="读书笔记" scheme="http://CalvinCheung.coding.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods 安装和基本使用</title>
    <link href="http://CalvinCheung.coding.me/2017/10/11/installationCocoapods/"/>
    <id>http://CalvinCheung.coding.me/2017/10/11/installationCocoapods/</id>
    <published>2017-10-11T13:33:22.000Z</published>
    <updated>2019-03-02T11:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司电脑莫名奇妙的没有了 <code>Cocoapods</code> 环境，所以又重新安装了一下，在此做一个记录。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>Mac</code> 下都自带 <code>ruby</code>，使用 <code>ruby</code> 的 <code>gem</code> 命令即可下载安装。</p><p>打开 <code>Terminal</code>，然后输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div><div class="line">pod setup</div></pre></td></tr></table></figure><p><font color="red"># 注意：</font>苹果系统 OS X EL Capitan(版本10.11.3) 后安装代码:<code>sudo gem install -n /usr/local/bin cocoapods</code></p><p>10.11之前用 <code>sudo gem install cocoapods</code>。</p><p>如果 <code>gem</code> 版本太老，可以尝试用如下命令升级 <code>gem</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo gem update --system</div></pre></td></tr></table></figure><p>还有一点需要注意，<code>pod setup</code> 在执行时，会输出 <code>Setting up CocoaPods master repo</code>，但是会等待比较久的时间。这步其实是 <code>Cocoapods</code> 在将它的信息下载到 <code>~/.cocoapods</code> 目录下。</p><p>另外，<code>ruby</code> 的软件源 <code>https://rubygems.org</code> 被墙了，为了方便我们使其替换为国内淘宝的源：</p><p>查看 Ruby 源</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure><p>移除现有 Ruby 默认源</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources --remove https://rubygems.org/</div></pre></td></tr></table></figure><p>将 Ruby 源指向淘宝镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem sources -a https://ruby.taobao.org/</div></pre></td></tr></table></figure><h3 id="检测和重新安装"><a href="#检测和重新安装" class="headerlink" title="检测和重新安装"></a>检测和重新安装</h3><p>最后检查 pod 是否安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pod --version</div></pre></td></tr></table></figure><p>在这里能检测到版本就代表已经安装</p><p>如果出现 <code>pod: command not found</code>，说明还没有安装。</p><p>如果已安装想要重新安装，输入以下命令卸载 pod：<code>sudo gem uninstall cocoapods</code></p><p>然后执行安装下载命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div><div class="line">pod setup</div></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>新建一个项目，在终端 <code>cd</code> 到该项目的根目录下</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure><p>打开生成的 <code>Podfile</code> 文件并设置</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Uncomment the next line to define a global platform for your project</div><div class="line"># platform :ios, &apos;9.0&apos;</div><div class="line"></div><div class="line">target &apos;TestCocos&apos; do</div><div class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class="line">  # use_frameworks!</div><div class="line"></div><div class="line">  # Pods for TestCocos</div><div class="line"></div><div class="line">pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos;</div><div class="line">pod ‘AFNetworking’, ‘~&gt; 3.1.0’</div><div class="line"></div><div class="line">end</div></pre></td></tr></table></figure><p>将 <code>Podfile</code> 文件设置成功后</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure><p><code>CocoaPods</code> 会帮我们下载好代码，设置好编译参数，配置好 framework， library。</p><h3 id="查找第三方库"><a href="#查找第三方库" class="headerlink" title="查找第三方库"></a>查找第三方库</h3><p>你如果不知道 <code>cocoaPods</code> 管理的库中，是否有你想要的库，那么你可以通过 <code>pod search</code> 命令进行查找，例如查找 <code>afnetworking</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ pod search afnetworking</div><div class="line"></div><div class="line">-&gt; AFNetworking (3.1.0)</div><div class="line">   A delightful iOS and OS X networking framework.</div><div class="line">   pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div><div class="line">   - Homepage: https://github.com/AFNetworking/AFNetworking</div><div class="line">   - Source:   https://github.com/AFNetworking/AFNetworking.git</div><div class="line">   - Versions: 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2, 3.0.0-beta.1,</div><div class="line">   2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4,</div><div class="line">   2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2, 2.0.0-RC1,</div><div class="line">   1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1,</div><div class="line">   0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0, 0.7.0, 0.5.1 [master repo]</div><div class="line">   - Subspecs:</div><div class="line">     - AFNetworking/Serialization (3.1.0)</div><div class="line">     - AFNetworking/Security (3.1.0)</div><div class="line">     - AFNetworking/Reachability (3.1.0)</div><div class="line">     - AFNetworking/NSURLSession (3.1.0)</div><div class="line">     - AFNetworking/UIKit (3.1.0)</div><div class="line"></div><div class="line">-&gt; AFNetworking+AutoRetry (0.0.5)</div><div class="line">   Auto Retries for AFNetworking requests</div><div class="line">   pod &apos;AFNetworking+AutoRetry&apos;, &apos;~&gt; 0.0.5&apos;</div><div class="line">   - Homepage: https://github.com/shaioz/AFNetworking-AutoRetry</div><div class="line">   - Source:   https://github.com/shaioz/AFNetworking-AutoRetry.git</div><div class="line">   - Versions: 0.0.5, 0.0.4, 0.0.3, 0.0.2, 0.0.1 [master repo]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;公司电脑莫名奇妙的没有了 &lt;code&gt;Cocoapods&lt;/code&gt; 环境，所以又重新安装了一下，在此做一个记录。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;&lt;cod
      
    
    </summary>
    
      <category term="iOSDev" scheme="http://CalvinCheung.coding.me/categories/iOSDev/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>读书 -《硅谷革命：成就苹果公司的疯狂往事》</title>
    <link href="http://CalvinCheung.coding.me/2017/09/25/readNote-Apple/"/>
    <id>http://CalvinCheung.coding.me/2017/09/25/readNote-Apple/</id>
    <published>2017-09-25T13:59:54.000Z</published>
    <updated>2019-03-02T11:04:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果提起苹果公司，很多人应该最熟悉的就是乔布斯、iPhone 手机了吧，但是如果说起苹果的历史，应该鲜有人能说出一个一二三来。</p><p>周末终于把周一收到的一本书读了一下，书名就叫做《硅谷革命》，副标题是成就苹果公司的疯狂往事。本书的内容是关于苹果公司开发 Macintosh 的历史。读完此书也算是对苹果公司的尘封往事有了些许了解，在次总结一下读书心得。</p><h4 id="工程师文化"><a href="#工程师文化" class="headerlink" title="工程师文化"></a>工程师文化</h4><p>虽然我不曾在崇尚工程师文化的公司待过。但我想，如果你是一个工程师，肯定会想在那样的环境下工作的。Macintosh 开发团队的工程师，每一个都可以称得上是极客，每个人都怀揣改变世界的梦想，当然这些也是环境使然，毕竟不是每个人都有机会经历像 Macintosh 这样的大变革时代的。不过，我在读此书的过程中，每当看到作者的描写当时每个人为了 Macintosh 忘我付出的时候，心中也是热血澎湃。</p><p>后来团队管理出现了一些问题，当时的乔布斯也还没有被苹果”放逐”，团队管理上存在一些问题，Macintosh 电脑可以说就是经历了从开发到巅峰，再从巅峰跌入低谷的过程。但书中的很多文字依然留给我了很多可以思考的东西。</p><p>比如：如何处理与团队成员之间以及和领导间的关系，因为作者的经历也可以让我从中受到启发。还有，如何面对挑战以及解决困难、如何发挥自己的创意，实现或者创造出好玩的东西等等，而这些都是作者以及团队成员的经历。</p><h4 id="另一个乔布斯"><a href="#另一个乔布斯" class="headerlink" title="另一个乔布斯"></a>另一个乔布斯</h4><p>全书也有很多对乔布斯的描写，和我从《乔布斯传》《成为乔布斯》等传记中所了解的乔布斯不同的是，在开发 Macintosh 的过程中，你能通过文字感受到乔布斯那种『现实扭曲立场』的魔力。当然，乔布斯也不是神人，在当时管理团队的过程中也能感受到他的狂妄与桀骜不逊的一面。</p><p>书中还有很多商业的细节，尤其是苹果和其他公司以及苹果和微软公司的合作。以及『1984』广告的拍摄，Macintosh 电脑发布迅速让 Macintosh 走向巅峰，但由于种种原因也很快跌入谷底。而此后不久，乔布斯也被自己招聘的副总裁给踢出苹果公司。</p><p>当然，30多年过去了，苹果的发展很快，整个世界的发展也很快。如果除去乔布斯，除去苹果公司的部分不谈，哪怕只看 Macintosh 开发的过程依旧能够看到现在公司或者团队的影子。</p><p>一个团队，人数不多，但是每个都有极客般的热情和目标，在30年后的今天，类似 Macintosh 这样的变革的产品依然被不断的发明、被创造出来。虽然当今社会创新的难度加大了，但是看到这样的极客文化、工程师文化，多多少少都能找到一些30年前的影子。</p><p>下面摘录一些书中的片段，当然，读这本书会比这些精彩的多。</p><h4 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h4><blockquote><p>一些管理者试图通过代码行数来衡量工程师的工作进度和代码质量，但 Bill Atkinson 却用更少的代码和更好的性能默默地扇了他们一巴掌。</p><div align="right"> ——《负 2000 行代码》</div></blockquote><p><br></p><blockquote><p>一个硬件工程师去面试软件工程师职位，并声称自己写过 35 万行代码，后来才知道他居然不知道还能在代码里使用循环。</p><div align="right"> ——《后来发现可以使用循环》</div></blockquote><p><br></p><blockquote><p>比尔·盖茨嘲笑乔布斯不会写代码，但他自己曾经和 Neil Konzen 一起写一款非常糟糕的游戏，而且在代码注释里留下了大名，反而成为一大笑柄。   </p><div align="right"> ——《驴子》</div></blockquote><h4 id="关于薪水"><a href="#关于薪水" class="headerlink" title="关于薪水"></a>关于薪水</h4><blockquote><p>Andy 从 Apple II 团队转到 Mac 团队，预计薪水会从 22000 美元一年涨到 24000 美元一年。但当他向主管提出加薪时，主管说：“这看起来很合理，但是有个小问题，我的年薪也才 20000 美元而已。”</p><div align="right">——《被宠坏》</div></blockquote><h4 id="关于加班"><a href="#关于加班" class="headerlink" title="关于加班"></a>关于加班</h4><blockquote><p>Mac 团队大部分成员的年龄介于 20 到 30 岁之间，没什么家事牵绊，所以大家都习惯了长时间的工作。他们对项目都相当投入，愿意把生命的全部都奉献给项目。即使是三十多年后的今天，加班依然是 IT 公司的常态，但背后的推动力却不一样了。</p><div align="right"> ——《乐在其中的每周 90 小时》</div></blockquote><h4 id="关于荣誉"><a href="#关于荣誉" class="headerlink" title="关于荣誉"></a>关于荣誉</h4><blockquote><p>作为 Lisa 主要设计师的 Bill Atkinson 却没能与他的经理们一同参加杂志的专访，因为他的头衔只是个工程师，他的付出无法得到肯定，感觉受到了不公平待遇。</p><div align="right">——《实至名归》</div></blockquote><h4 id="关于“傲气”"><a href="#关于“傲气”" class="headerlink" title="关于“傲气”"></a>关于“傲气”</h4><blockquote><p>Andy 的主管决定要给 Andy 一次差评，因为他觉得 Andy“不服从管理，也不尊重职权，妨碍了团队的其他人，而且太自视甚高了”。</p><div align="right"> ——《自视甚高》</div></blockquote><h4 id="关于挑战"><a href="#关于挑战" class="headerlink" title="关于挑战"></a>关于挑战</h4><blockquote><p>“我开始明白为什么 Burrell 做的很多事情都能如此成功，他和其他表现优异的人一样，都很喜欢挑战，甚至自己寻求挑战或刻意自造困难，他似乎一生都在积极寻求挑战。”</p><div align="right"> ——《先搞砸再收拾》</div></blockquote><h4 id="关于创意"><a href="#关于创意" class="headerlink" title="关于创意"></a>关于创意</h4><blockquote><p>百分之九十的创意都是“偷”来的。微软从苹果“偷”走了系统界面，乔布斯大发雷霆，而比尔·盖茨却说：“应该说我们都有一个名叫 Xerox 的有钱邻居，我潜入他家偷电视，却发现早被你偷走了。”</p><div align="right"> ——《有个富翁邻居叫 Xerox》</div></blockquote><h4 id="关于成长"><a href="#关于成长" class="headerlink" title="关于成长"></a>关于成长</h4><blockquote><p>Andy 在停薪留职结束之后与乔布斯会餐，希望乔布斯能够把 Mac 团队恢复到之前的状态。但乔布斯说：“团队需要成长，你也是。我们希望你能回来，但如果你不愿意的话，那随便你，反正你也没有自己想象得那么重要。”</p><div align="right"> ——《一切都再好不过了》</div></blockquote><h4 id="关于内部竞争"><a href="#关于内部竞争" class="headerlink" title="关于内部竞争"></a>关于内部竞争</h4><blockquote><p>Lisa 的主要设计师 Rich Page 看着 Mac 即将挤掉 Lisa 的位置，怒气冲冲地跑进会议室大喊：“乔布斯想要毁了 Lisa，就因为我们不想让他控制 Lisa……你们回去告诉乔布斯，我认为他正在摧毁苹果！”</p><div align="right"> ——《还有一件事》</div></blockquote><h4 id="关于外部竞争"><a href="#关于外部竞争" class="headerlink" title="关于外部竞争"></a>关于外部竞争</h4><blockquote><p>Adam Osborne 在电脑展会上藐视 Mac，Andy 把这件事情告诉了乔布斯。于是乔布斯打电话给 Adam 的秘书：“你帮我告诉 Adam，他是个混蛋！听说他对 Mac 很好奇。你告诉他，Mac 好到会让他的公司关门大吉，而且连他自己都会给他的孩子买上好几台。”</p><div align="right"> ——《给 Adam 的留言》</div></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果提起苹果公司，很多人应该最熟悉的就是乔布斯、iPhone 手机了吧，但是如果说起苹果的历史，应该鲜有人能说出一个一二三来。&lt;/p&gt;
&lt;p&gt;周末终于把周一收到的一本书读了一下，书名就叫做《硅谷革命》，副标题是成就苹果公司的疯狂往事。本书的内容是关于苹果公司开发 Macin
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
      <category term="读书笔记" scheme="http://CalvinCheung.coding.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iPhone X 简单适配</title>
    <link href="http://CalvinCheung.coding.me/2017/09/21/The-iPhone-X-adaptation/"/>
    <id>http://CalvinCheung.coding.me/2017/09/21/The-iPhone-X-adaptation/</id>
    <published>2017-09-21T12:57:46.000Z</published>
    <updated>2019-03-02T11:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 11 正式版系统发布后，Xcode 9 也正式发布了，今天正好抽时间对项目进行 iPhone X 的适配。</p><p>今年 iPhone 变化最大的当属 iPhone X 了，由于屏幕使用全面屏，并且额头保留了『刘海』以及『耳朵』，导致大部分 App 必须对它进行适配。所幸 iPhone X 使用的图片依旧是 @3x，在适配时仅需要设置部分单独的图片并且处理一下顶部和底部的显示就好了。</p><p><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/iphone-x/" target="_blank" rel="external">Apple 官方人机交互指南 iPhone X 部分</a> 详细介绍了 iPhone X 的分辨率、安全显示区域等，想更好适配的可以仔细研读一下。</p><h3 id="App-直接在-iPhone-X-运行"><a href="#App-直接在-iPhone-X-运行" class="headerlink" title="# App 直接在 iPhone X 运行"></a><font color="red">#</font> App 直接在 iPhone X 运行</h3><p>先看一下在 iPhone X 直接运行 App 的效果</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/201709211506000654153.png" alt="201709211506000654153.png"></p><p>之所以出现 App 顶部和底部大面积变黑的原因是因为没有设置对应机型的启动图片。为了让 App 充满整个屏幕。我们先设置一张启动图。</p><h3 id="设置-iPhone-X-启动图"><a href="#设置-iPhone-X-启动图" class="headerlink" title="# 设置 iPhone X 启动图"></a><font color="red">#</font> 设置 iPhone X 启动图</h3><p>iPhone X 的分辨率为 1125 * 2436，所以先准备一张这个尺寸的启动图。</p><p>如果项目启动页使用的是 LaunchImage，可以直接修改 Contents.json 文件，添加一条 iPhone X 启动图的设置。（注意json格式）如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;extent&quot; : &quot;full-screen&quot;,</div><div class="line">    &quot;idiom&quot; : &quot;iphone&quot;,</div><div class="line">    &quot;subtype&quot; : &quot;2436h&quot;,</div><div class="line">    &quot;filename&quot; : &quot;启动页名称.png&quot;,</div><div class="line">    &quot;minimum-system-version&quot; : &quot;11.0&quot;,</div><div class="line">    &quot;orientation&quot; : &quot;portrait&quot;,</div><div class="line">    &quot;scale&quot; : &quot;3x&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果使用的是 LaunchScreen.storyboard，则需要在对应的 storyboard 设置。成功后再次运行 App 则会正常充满屏幕。</p><h3 id="页面布局设置"><a href="#页面布局设置" class="headerlink" title="# 页面布局设置"></a><font color="red">#</font> 页面布局设置</h3><blockquote><p>Most apps that use standard, system-provided UI elements like navigation bars, tables, and collections automatically adapt to the device’s new form factor. Background materials extend to the edges of the display and UI elements are appropriately inset and positioned.</p></blockquote><p>使用官方标准控件基本上苹果会自动的进行页面布局处理，你要修改的地方就很少了。但是有些情况就比较特殊。</p><p>1、设置 navigationController 高度为64或者设置 statusBar 高度为20，以及 statusBar 隐藏等，需要进行修改调整。</p><p>因为苹果 statusBar 高度由20变成了44，navigation bar 则保持44不变，也就是其他机型上的 navigationController 默认写成 64 的，则需要对其进行设置为88。</p><p>对于 iPhone 机型的识别可以根据如下的设备型号进行判断。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="string">@"iPhone10,1"</span> : <span class="string">@"iPhone 8"</span>,</div><div class="line"><span class="string">@"iPhone10,4"</span> : <span class="string">@"iPhone 8"</span>,</div><div class="line"><span class="string">@"iPhone10,2"</span> : <span class="string">@"iPhone 8 Plus"</span>,</div><div class="line"><span class="string">@"iPhone10,5"</span> : <span class="string">@"iPhone 8 Plus"</span>,</div><div class="line"><span class="string">@"iPhone10,3"</span> : <span class="string">@"iPhone X"</span>,</div><div class="line"><span class="string">@"iPhone10,6"</span> : <span class="string">@"iPhone X"</span>,</div></pre></td></tr></table></figure><p>2、部分项目对 UITabBar 进行了自定义，也有可能出现问题。</p><p>比如『图拉鼎』同学的奇点App，由于自定义了 TabBar，出现了如图的问题</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170921150600169732035.png" alt="20170921150600169732035.png"></p><p>这个问题的解决，可以移步 <a href="https://imtx.me/archives/2374.html" target="_blank" rel="external">图拉鼎同学的博客</a> 查看。</p><h3 id="使用-MJRefresh-下拉刷新问题"><a href="#使用-MJRefresh-下拉刷新问题" class="headerlink" title="# 使用 MJRefresh 下拉刷新问题"></a><font color="red">#</font> 使用 MJRefresh 下拉刷新问题</h3><p>网上部分在开发者在进行 iOS 11 适配的时候出现的问题，但是后来发现是由于 iOS 11 API 变化导致。</p><p>iOS11 弃用了 <code>automaticallyAdjustsScrollViewInsets</code> 属性，新增<code>contentInsetAdjustmentBehavior</code> 来替代。</p><p>如果不想系统帮我们自动设置边距则要在 iOS 11 中加上这句代码</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">scrollView.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</div></pre></td></tr></table></figure><p>Swift 使用如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> #available(iOS <span class="number">11.0</span>, *) &#123; collectionView.contentInsetAdjustmentBehavior = .never &#125; <span class="keyword">else</span> &#123; <span class="comment">// Fallback on earlier versions &#125;</span></div></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="# 小结"></a><font color="red">#</font> 小结</h3><p>由于适配项目目前结构比较简单，所以在 iPhone X 上并未出现太多问题。主要处理的位置有2块，一部分是顶部 statusBar 和 NavigationBar 的单独处理，以及底部超出安全区域页面的处理。</p><p>因为 iPhone X 的 Safe area，我们需要对一些页面做一下处理，关于 Safe area 的详细可以参考上文的苹果人机开发指南。</p><p>因为我主要使用官方控件并做一些简单自定义，最后适配问题很少，也很快完成，发一张部分页面的效果图</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2017092115060025749206.png" alt="2017092115060025749206.png"></p><p>如果项目页面比较复杂而且自定义控件比较多的话，可能还需要花费一些时间，尤其是安全区域的处理，以及屏幕方向切换等等问题。仔细写的话就比较多了，而且很多细节性的处理不具有代表性，在这里仅做大致的功能适配记录以供参考。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iOS 11 正式版系统发布后，Xcode 9 也正式发布了，今天正好抽时间对项目进行 iPhone X 的适配。&lt;/p&gt;
&lt;p&gt;今年 iPhone 变化最大的当属 iPhone X 了，由于屏幕使用全面屏，并且额头保留了『刘海』以及『耳朵』，导致大部分 App 必须对它进
      
    
    </summary>
    
      <category term="iOSDev" scheme="http://CalvinCheung.coding.me/categories/iOSDev/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>记录一下近况</title>
    <link href="http://CalvinCheung.coding.me/2017/09/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E8%BF%91%E5%86%B5/"/>
    <id>http://CalvinCheung.coding.me/2017/09/16/记录一下近况/</id>
    <published>2017-09-16T05:53:42.000Z</published>
    <updated>2019-03-02T10:58:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>转眼已经到了9月中旬，上海的天气也渐渐有了凉意。由于最近在新公司的工作比较忙，一直在赶新的项目，也没有抽出时间写技术博客。正好赶上周末就记录下最近的情况吧。</p><p>上个月中旬左右入职了这家公司，差不多也有一个月的时间了。初创公司，入职的当天就把我硬盘里事先准备好的工作软件安装到电脑开始进入工作状态了。当然这一个月也很充实，基本上没有闲过，一直在项目上，接下来就先说说最近的工作情况。</p><h4 id="为什么选择了这家公司？"><a href="#为什么选择了这家公司？" class="headerlink" title="为什么选择了这家公司？"></a>为什么选择了这家公司？</h4><p>上个月在现在公司入职时手中还有另外一家公司的 offer，公司业务是做小贷公司服务的，产品一句话总结就是小贷公司的钉钉吧。当时和这家公司的项目负责人以及公司 HR 都聊了很多，他们及时的给我发放了 offer，薪资也比我目前的公司高了一些，但是最终我选择了薪资更低的现在所在的公司报到，对方 HR 还打电话来询问情况，为什么不愿意加入他们等。当时没想到对方公司还打电话来，感觉挺不好意思的，只对 HR 说自己入职了另外一家公司就匆匆挂了电话。</p><p>另外，这家公司是初创公司，薪资也没有另外一家给的高，之所以选择了这家公司主要原因有2点：</p><p>1、公司业务是和区块链相关的，自我感觉业务还算比较有前景。<br>2、公司办公氛围好，全员 Mac 办公，上下班不打卡，时间上自由一些。工作安排好了就去做，按时完成并对接就好。</p><p>当然，虽然工作环境相对宽松，自己也是丝毫没有懈怠。入职前就先准备好工作中需要的软件包，入职当天办完手续就把软件安排好开始码代码了。</p><p>公司代码管理使用 Github，直接配置好随时随地在任何地方都可以办公，提交代码了。公司产品主要是 ToC 的钱包产品，主要功能是管理用户的数字资产。第一款产品因为安卓已经完成的差不多了，所以入职就直接按照安卓的功能进行开发。</p><p>因为第一款产品功能和业务逻辑相对简单一些，我在2周时间基本上就开发完毕了，时间上一点都没用耽误。第三周开始移交测试并修复 Bug。</p><p>而且这次申请邓白氏编码以及开发者账号也是及其的快，在写代码的2周时间内已经申请并开通了公司的苹果开发者帐号。</p><p>第三周一周的时间基本上就是测试，改 Bug 阶段，一周内修复完成并提交 AppStore。至此，公司的第一款简单产品告一段落。</p><h4 id="现在做的产品"><a href="#现在做的产品" class="headerlink" title="现在做的产品"></a>现在做的产品</h4><p>现在做的产品也是目前公司主力做的一款产品，是基于 QTUM 链进行开发的一款产品。基本功能就是 QTUM 和 代币的收付款转账。</p><p>基本功能的代码是基本 QTUM 官方开源的 iOS 代码进行开发的，QTUM 开发团队在白俄罗斯。当我把他们的代码 clone 下来以后就惊呆了，整个代码压缩后还有 100MB，生成软件包 50多 MB。由于开发时间比较紧，我就没有使用他们的代码，直接看他们的代码逻辑并进行抽离，从而进行功能实现。</p><p>真是应了那句话：每个人看别人的代码都感觉对方写的就是一坨屎。我看到他们代码的第一感觉也是如此，一个钱包应用没有太多功能却加入了那么多东西，而且代码中每个类都在使用代理，通知也使用了不少。看了2周他们的代码我简直到疯掉了。</p><p>好在代码剥离还算顺利，经过大概2周的时间已经把他们 App 的基本功能在我司的产品中进行了实现，而且目前我司的软件包才 3MB 大小。</p><p>下周要开发活动相关的功能了，而且接下来还有聊天、社交、商城等功能。估计接下来的2个月时间也会排的很满。不过在工作中实现了很多有趣的功能的时候，幸福感还是很强的。</p><p>虽说公司的工作环境相对宽松，不过小公司还是有很多小公司的弊端的。比如很多工作都要自己来，遇到问题需要自己去解决，尤其是在一些功能的实现以及出现问题的时候，都需要自己去摸索解决。并且钱包应用和传统的软件还有所不同，因为没有了注册登录的流程，也没有了用户的概念，这些都是很新奇需要自己很快接受并学习的东西。</p><h4 id="最近的所想所得"><a href="#最近的所想所得" class="headerlink" title="最近的所想所得"></a>最近的所想所得</h4><p>由于入职了这家公司，自己也逐渐了解到了比特币、区块链、以太坊等等的名词。平时也在关注这些话题。刚入职的时候，得到王煜全老师的新专栏《全球创新260讲》里有一周的时间都提到了这些内容，当时看到后果断订阅学习。</p><p>我经常在得到听音频，比如得到里的李笑来《通往财富自由之路》是得到订阅数量最多的一个专栏。在不了解比特币的信息的时候我对李笑来的了解还不多，但后来逐渐了解以后，才发现李笑来在整个”币圈”的名声可以说是一踏糊涂。</p><p>人就是需要这样不断的去了解和学习不同的东西，这样才能不至于陷入思维的陷阱，才能通过自己的所学所想去客观的看待一些事情和人。如果不是去了解比特币相关的东西的话，我肯定不会想到号称”中国比特币支首富”的李笑来老师在行内人眼中那么不受待见。</p><p>当然了，这些年其实经历过很多类似的事情，由于自己缺乏对一件事情的全面了解而做出一些片面的理解，有时候甚至是像个傻逼似的固执已见。所以，现在的我也在逐渐的改掉以前的一些片面思想，遇到问题在全面了解以后再做自己的判断。当然，这样的思维锻炼不是那么容易的。</p><p>举个例子：我住处附近的地铁站由于只有一个出入口，所以工作日每天早晨都要限流。首先在入口有很多护栏，进入地铁站需要排队。当然这个是可以理解的，毕竟人那么多，有了护栏以后大家分成几列进入地铁站会更有秩序。但让我不理解的事情是关闭地铁站的电梯，这个电梯每天早晨都会关闭，旁边写了是由于限流原因关闭电梯。可能很多人并不会在意这样的一个问题，但是如果你仔细想一下。当电梯没有关闭的时候，会有一帮人乘坐电梯上楼去等地铁，而下了地铁的人则会走电梯旁边的楼梯下楼出站。现在呢？电梯关闭，而每天上班的人并不会因为电梯关闭而减少，现在上楼等地铁的人要走楼梯，下楼出站的人也要走楼梯，这样就造成了一个楼梯上有上有下，人比较多还需要相互谦让一下，无形中让每个人的效率下降，每个人都要浪费时间。本来为了限流而关闭了电梯，在我看来，关闭了电梯不仅没有完成限流的目标，反而增加了每个人乘坐地铁的时间，还很有可能造成拥堵、踩踏等事件的发生。</p><p>如果没有这样的一个角度去看待地铁站限流，可能我们永远也意识不到有些部门的工作简直就是毫无用处，甚至还会造成资源的浪费。</p><p>最后，最近虽然工作很忙，不过自己业余时间也读了一些书，看了一些电影，当然还在准备10月份即将到来的几门考试。鉴于自己目前还没有很多有价值的输出，书单和电影就不在这里分享了，等年终的时候再做回顾好了。技术博客会尽量抽时间写写，也算记录下自己的成长吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼已经到了9月中旬，上海的天气也渐渐有了凉意。由于最近在新公司的工作比较忙，一直在赶新的项目，也没有抽出时间写技术博客。正好赶上周末就记录下最近的情况吧。&lt;/p&gt;
&lt;p&gt;上个月中旬左右入职了这家公司，差不多也有一个月的时间了。初创公司，入职的当天就把我硬盘里事先准备好的工
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>由技术发展所引发的个人思考</title>
    <link href="http://CalvinCheung.coding.me/2017/08/06/Technology-changes-the-world/"/>
    <id>http://CalvinCheung.coding.me/2017/08/06/Technology-changes-the-world/</id>
    <published>2017-08-06T11:00:23.000Z</published>
    <updated>2019-03-02T11:02:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>毋庸置疑，目前互联网上讨论最火的技术当属人工智能了，而作为一个技术从业者，虽然对人工智能技术的了解甚少，但最近读了一些技术相关的书籍以及观看了一些视频后，自我感觉技术对人类社会的发展影响深远。</p><h4 id="技术在改变着人类的社会发展"><a href="#技术在改变着人类的社会发展" class="headerlink" title="# 技术在改变着人类的社会发展"></a><font color="red">#</font> 技术在改变着人类的社会发展</h4><p>对这句话的深刻思考源于前几天看过的一个纪录片<a href="https://movie.douban.com/subject/20277091/" target="_blank" rel="external">《美国商业大亨传奇 The Men Who Built America》 (2012)</a>，这部纪录片讲述了19世纪中后期20世纪前期的美国商业大亨的故事，其中包括铁路大王范德比尔特、石油大亨洛克菲勒、钢铁大王卡内基、摩根以及亨利福特。</p><p>而这些故事发生的时点正逢<a href="https://zh.wikipedia.org/zh-hans/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B7%A5%E4%B8%9A%E9%9D%A9%E5%91%BD" target="_blank" rel="external">第二次工业革命</a>，而就是这些商业大亨在铁路、石油、钢铁、电力、汽车等方面的贡献，使得美国短短几十年的时间就成为了世界第一强国。</p><p>第二次工业革命的主要标志就是电力的广泛使用，根据这部纪录片中的讲述，正是由于范德比尔特在铁路方面加速了美国生产力的发展，连接了美国的东西部；洛克菲勒对石油的研究改变了美国人民的照明和生产方式，而卡内基的钢铁建设了美国；摩根看到这些大亨的成就，也想做改变美国以及改变世界的事情，是爱迪生发明的电灯让他找到了一个值得冒险的机会。</p><p>虽然摩根在推广电力的事情上发生了很多意外，但电力的大力发展和推广无疑奠定了美国在世界上第一强国的地位。</p><p>如果再仔细研究目前的互联网技术或者新科技的发展，维基百科又称此为<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%97%E5%8C%96%E9%9D%A9%E5%91%BD" target="_blank" rel="external">第三次科技革命</a>，毫无疑问，第三次科技革命的领头羊依旧是美国。也正因如此，现在在世界500强的互联网企业中美国才会占据那么多席位。</p><p>无独有偶，前几天一口气读完了阮一峰老师的<a href="https://ruanyf.github.io/survivor/index.html" target="_blank" rel="external">未来世界的幸存者</a>，其中有一篇文章很有意思。在<font color="red">技术决定历史</font>一文中，阮一峰老师提到他大学读的是世界经济专业，在学习《经济史》之前，阮一峰老师一直觉得政治最重要，决定了历史的变迁。</p><p>而学完了《经济史》之后，他的观念改变了，他在文章中这样说道：“学了《经济史》，我认识到，经济比政治更重要。政治人物只是舞台上的演员，剧情走向早由经济因素决定了。”</p><p>而又在经历了经济危机以及阮一峰老师学习了编程技术以后，他对待历史的看法又一次发生了改变。在他读完大量技术书籍以后，他这样说：</p><blockquote><p>熟悉科技史以后，我看待历史的观点，再一次发生了巨大的变化。我现在认为，主导历史的因素，短期（一年到几年）是政治，中期（几年到几十年）是经济，长期（几十年到几百年）则是技术。<br><br>长期来看，政治和经济都不太重要，影响不了趋势，真正起决定性作用的是技术。政治和经济只能改变资源的分配和价格，只有技术才能创造出新东西。政治和经济只能使人类在平面上移动，只有技术才能使得人类向上提升，进入下一个阶段。</p></blockquote><p>阮一峰老师的观点是技术决定历史，而历史正是我们现在的经历所产生的。所以，对于技术的发展以及预测，基本上就可以说是在预测未来。包括我们以前看过的很多科幻电影，里面很多情节、很多事物都是当时的人们对未来想象而来的，但科幻电影里面的情节也好，事物也罢，都是由技术发展演进而来的。</p><p>如果科幻电影里的情节成为了现实，也只能说导演或者编剧预测对了技术的发展或者走向，从而预测对了未来的生活。</p><h4 id="人工智能对中国有利吗？"><a href="#人工智能对中国有利吗？" class="headerlink" title="# 人工智能对中国有利吗？"></a><font color="red">#</font> 人工智能对中国有利吗？</h4><p>马云前几年有一次演讲中提到：现在是 IT 时代向 DT 时代转换的时期，而阿里未来要做DT相关的公司。而此处的 D 就是 data(数据)。</p><p>前段时间 AlphaGo 打败中国棋手柯洁，说白了就是运用了数据打败了柯洁，并不是说 AlphaGo 有多聪明，而是谷歌的深度学习系统在掌握了大量的围棋对阵数据后进行再处理的结果。</p><p>得益于云计算的发展，使得大数据的处理变成可能，而目前的人工智能还处于通过大量的数据处理进行学习的阶段，因此 AlphaGo 在掌握浩瀚的数据并深度学习之后再来打败柯洁一点也不奇怪。</p><p>当然，人工智能发展需要的最重要的就是数据，在这方面，中国因为有较多的人口，产生的数据理论上也会更多，应该还是有比较大的优势的。</p><p>比如目前的淘宝的商品推荐系统就是根据大量的数据进行机器学习的结果，用户在淘宝购物的过程中产生了大量的浏览数据，正是对这些数据的处理，淘宝可以在不需要人工介入的情况下进行对应的商品推荐，这就是数据的力量。</p><p>类似的例子还有很多，比如客服系统，电商平台可以根据用户数据进行深度学习从而研发出来智能的客服机器人，这样就可以大量的减少客服人员也能达到很好的客服沟通和处理工作。</p><p>还有百度的无人驾驶汽车，正是得益于深度学习、机器学习等技术，使用大量的数据对机器进行驯化，最后可以得到一个比人类驾驶更安全、更可靠的驾驶系统。</p><p>当然，人工智能可以做的事情还有很多很多，目前我们在可预见的未来会出现很多基础的人工智能系统。未来，肯定也会有更多我们预测不到的人工智能系统，到时候系统所做的事情就不得而知了。</p><p>昨天看了一篇王煜全老师《新技术与新趋势》的万字笔记，其中他提到了工人智能，也对美国的人工智能产业和中国的人工智能产业进行了对比，他提出人工智能的入口是客厅，即客厅的电视，电视需要有视频内容或者电商内容去支撑。美国人工智能做的最好的是亚马逊，而中国能与之相对应的企业就是乐视，但是乐视选错了战略方向，导致现在中国目前没有企业能与亚马逊相对应。当然，他也不止谈到了人工智能，还有其他很多的东西，如果有兴趣可以阅读这篇文章：<a href="http://weibo.com/ttarticle/p/show?id=2309404137512632236011&amp;is_all=1#_0" target="_blank" rel="external">王煜全《新技术与新趋势》课程万字深度笔记</a>。</p><h4 id="技术人员又该何去何从？"><a href="#技术人员又该何去何从？" class="headerlink" title="# 技术人员又该何去何从？"></a><font color="red">#</font> 技术人员又该何去何从？</h4><p>学习它、跟随它。</p><p>正如苹果在 iOS 11 系统中加入了 ARKit 以及 ML(Machine Learning) 技术一样，大公司也在努力把这些前沿技术变成现实从而进行普及，ARKit 框架使得一台 iPhone 就能随时随地体验 AR 技术带来的便利，目前网络上也有了很多的新奇的 AR App，就像百度地图也在其应用内内置了 AR 实景导航，这样的技术带给普通人的更多的是便利，需要快速普及开来。而且 ML 也提供了一系列 SDK 供开发者使用，开发者在使用的过程中也是在驯化苹果的机器学习这个“大玩具”。</p><p>而机器学习、深度学习等技术在网络上也比比皆是，未来，会有越来越多的公司进行这方面的研究和开发，到时候肯定需要大量的数据处理、数据挖掘、机器学习等方面的人才。</p><p>当然，未来的技术发展不仅仅是人工智能一个方向，或许未来的新兴技术会越来越多，怎么样去判断技术的发展趋势并顺应它，对我们来说就是一个很困难的问题了。</p><p>就像尤瓦尔·赫拉利在《未来简史》中提到的那样，当人文主义这个故事讲述不下去的时候，世界可能就会由“数据教”来进行统治了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;毋庸置疑，目前互联网上讨论最火的技术当属人工智能了，而作为一个技术从业者，虽然对人工智能技术的了解甚少，但最近读了一些技术相关的书籍以及观看了一些视频后，自我感觉技术对人类社会的发展影响深远。&lt;/p&gt;
&lt;h4 id=&quot;技术在改变着人类的社会发展&quot;&gt;&lt;a href=&quot;#技术在
      
    
    </summary>
    
      <category term="闲言碎语" scheme="http://CalvinCheung.coding.me/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>Xcode9 + iOS11 实现真机无数据线调试</title>
    <link href="http://CalvinCheung.coding.me/2017/07/14/xcode-wireless-debugging/"/>
    <id>http://CalvinCheung.coding.me/2017/07/14/xcode-wireless-debugging/</id>
    <published>2017-07-14T06:08:07.000Z</published>
    <updated>2019-03-02T11:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>WWDC 2017</code> 后，<code>Xcode</code> 支持真机无线调试了，不过现在 <code>Xcode9</code> 和 <code>iOS11</code> 目前都没有发布正式版本，想要体验的话必须安装 <code>Xcode9</code> 和 <code>iOS11</code> 的 <code>beta</code> 版。下面演示一下怎么样来设置真机无线调试。</p><a id="more"></a><p>1.首先确保安装 <code>iOS11</code> 的 <code>iPhone</code> 或者 <code>iPad</code> 连接到 电脑上。</p><p>2.在 <code>Xcode</code> 菜单栏选择 <code>Window &gt; Devices and Simulators</code>, 选中左边的 <code>Devices</code></p><p>如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170714150001286777546.png" alt=""></p><p>出现自己的设备后，勾选 <code>Connect via network</code> 选项，勾选后可以在左侧看到设备名称后面出现一个网络连接的图标。如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170714150001312253326.png" alt="20170714150001312253326.png"></p><p>当连接成功后拔掉数据线，在 <code>Xcode</code> 运行时依旧可以选择刚才的设备，如图所示，<code>Xcode</code> 运行成功，手机也已经拔掉了数据线，软件成功运行。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170714150001398087462.png" alt="20170714150001398087462.png"></p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170714150001401891855.png" alt="20170714150001401891855.png"></p><p>只要保证 <code>Mac</code> 和 调试设备在同一网络下即可，唯一的缺点就是设备不连 <code>Mac</code> 了，耗电量也加快了😂😂😂</p><p><a href="https://help.apple.com/xcode/mac/9.0/index.html?localePath=en.lproj#/devbc48d1bad" target="_blank" rel="external">官方无线调试文档地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;WWDC 2017&lt;/code&gt; 后，&lt;code&gt;Xcode&lt;/code&gt; 支持真机无线调试了，不过现在 &lt;code&gt;Xcode9&lt;/code&gt; 和 &lt;code&gt;iOS11&lt;/code&gt; 目前都没有发布正式版本，想要体验的话必须安装 &lt;code&gt;Xcode9&lt;/code&gt; 和 &lt;code&gt;iOS11&lt;/code&gt; 的 &lt;code&gt;beta&lt;/code&gt; 版。下面演示一下怎么样来设置真机无线调试。&lt;/p&gt;
    
    </summary>
    
      <category term="DevTips" scheme="http://CalvinCheung.coding.me/categories/DevTips/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发之 Block</title>
    <link href="http://CalvinCheung.coding.me/2017/07/06/iOS-Block/"/>
    <id>http://CalvinCheung.coding.me/2017/07/06/iOS-Block/</id>
    <published>2017-07-06T03:52:46.000Z</published>
    <updated>2019-03-02T11:03:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于-Block"><a href="#关于-Block" class="headerlink" title="关于 Block"></a>关于 Block</h3><p>在 iOS4.0之 后，block 横空出世，它本身封装了一段代码并将这段代码当做变量，通过 <code>block()</code> 的方式进行回调。这不免让我们想到在C函数中，我们可以定义一个指向函数的指针并且调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">executeSomeTask</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="comment">//do something and return if success or not</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">bool</span> (*taskPoint)(<span class="keyword">void</span>);</div><div class="line">taskPoint = something;</div></pre></td></tr></table></figure><a id="more"></a><p>上面的函数指针可以直接通过 <code>(*taskPoint)()</code> 的方式调用 <code>executeSomeTask</code> 这个函数，这样对比 block 跟似乎 C 语言的函数指针是一样的，但是两者仍然存在以下区别：</p><ol><li>block 的代码是内联的，效率高于函数调用</li><li>block 对于外部变量默认是只读属性</li><li>block 被 Objective-C 看成是对象处理</li></ol><h3 id="Block-特性"><a href="#Block-特性" class="headerlink" title="Block 特性"></a>Block 特性</h3><h4 id="认识-Block"><a href="#认识-Block" class="headerlink" title="认识 Block"></a>认识 Block</h4><p>Block 代码结构如下：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170706149931057994690.jpg" alt="20170706149931057994690.jpg"></p><p>先来看一个简单的block吧：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> (^isInputEven)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> input) &#123;</div><div class="line"><span class="keyword">if</span> (input % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>以上定义了一个 block 变量，block 本身就是一个程序段，因此有返回值有输入参数，这里这个 block 返回的类型为 <code>BOOL</code>。<code>^</code>符号表示 block 定义的开始，block 的名称紧跟在<code>^</code>符号之后，这里block的名称是 <code>isInputEven</code>。这段 block 接受一个 <code>int</code> 型的参数，而在等号后面的 <code>int input</code> 是对这个传入 int 参数的说明：在该 block 内，将使用 inpu t这个名字来指代传入的 int 参数。</p><p>调用这个block的方法就非常简单和直观了，类似调用c函数的方式即可：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">-101</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d %@ number"</span>, x, isInputEven(x) ? <span class="string">@"is an even"</span> : <span class="string">@"is not an even"</span>);</div></pre></td></tr></table></figure><p>不出意外的话输出为 <code>-101 is not an even number</code>。</p><h4 id="Block-递归调用"><a href="#Block-递归调用" class="headerlink" title="Block 递归调用"></a>Block 递归调用</h4><p>Block 想要递归调用，代码块变量必须是全局变量或者是静态变量，这样在程序启动的时候 Block 变量就初始化了，可以递归调用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> (^ <span class="keyword">const</span> blocks)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> i)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;  </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num:%d"</span>, i);  </div><div class="line">        blocks(i - <span class="number">1</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line">blocks(<span class="number">3</span>);</div></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">num:<span class="number">3</span></div><div class="line">num:<span class="number">2</span></div><div class="line">num:<span class="number">1</span></div></pre></td></tr></table></figure><h4 id="在-Block-中使用局部变量和全局变量"><a href="#在-Block-中使用局部变量和全局变量" class="headerlink" title="在 Block 中使用局部变量和全局变量"></a>在 Block 中使用局部变量和全局变量</h4><p>使用全局变量</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> global = <span class="number">1000</span>;  </div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;  </div><div class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)  </div><div class="line">        &#123;  </div><div class="line">            global++;  </div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"global:%d"</span>, global);  </div><div class="line">        &#125;;  </div><div class="line">        block();  </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"global:%d"</span>, global);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">global:<span class="number">1001</span></div><div class="line">global:<span class="number">1001</span></div></pre></td></tr></table></figure><p>而局部变量可以使用，但是不能改变。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> local = <span class="number">500</span>;  </div><div class="line"></div><div class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)  </div><div class="line">&#123;  </div><div class="line">    local++;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"local:%d"</span>, local);  </div><div class="line">&#125;;  </div><div class="line">block();  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"local:%d"</span>, local);</div></pre></td></tr></table></figure><p>在代码块中改变局部变量编译不通过。怎么在代码块中改变局部变量呢？在局部变量前面加上关键字：<code>__block</code></p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">__block <span class="keyword">int</span> local = <span class="number">500</span>;  </div><div class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)  </div><div class="line">&#123;  </div><div class="line">    local++;  </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"local:%d"</span>, local);  </div><div class="line">&#125;;  </div><div class="line">block();  </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"local:%d"</span>, local);</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">local:<span class="number">501</span></div><div class="line">local:<span class="number">501</span></div></pre></td></tr></table></figure><h4 id="Block-回调"><a href="#Block-回调" class="headerlink" title="Block 回调"></a>Block 回调</h4><p>先定义 RootViewController，初始化一个 UILabel 和 UIButton，点击 Button 页面跳转到 SecViewController，在 SecViewController 文本框内输入文字并返回到 RootViewController，此时在 SecViewController 页面输入的文本展示到 RootViewController 上。</p><p>需要回调数据的是 Root 视图，那么 Block 就应该在 SecView 中定义，用于获取传入回调数据。</p><p>我们在 SecViewController.h  定义了 <code>typedef void (^BlockValue)(NSString *value)</code> 的别名为 <code>BlockValue</code> 。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^BlockValue)(<span class="built_in">NSString</span> *value);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecViewController</span> : <span class="title">UIViewController</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) BlockValue myBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>点击 Sec 页面的按钮时添加 <code>BlockValue</code> 的传参操作：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)btnClicked&#123;</div><div class="line">    <span class="keyword">self</span>.myBlock(<span class="keyword">self</span>.textField.text);</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们就可以在想要获取数据回调的地方，也就 RootViewController 的视图中调用 block：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)btnClicked&#123;</div><div class="line">    </div><div class="line">    SecViewController *sec = [[SecViewController alloc]init];</div><div class="line">    <span class="comment">// 弱引用转换,为了防止循环引用</span></div><div class="line">    __<span class="keyword">weak</span> RootViewController *weakSelf = <span class="keyword">self</span>;</div><div class="line">    sec.myBlock = ^(<span class="built_in">NSString</span> *value) &#123;</div><div class="line">        weakSelf.label.text = value;        </div><div class="line">    &#125;;</div><div class="line">    [<span class="keyword">self</span> presentViewController:sec animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2017070614993130281040.gif" alt="2017070614993130281040.gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于-Block&quot;&gt;&lt;a href=&quot;#关于-Block&quot; class=&quot;headerlink&quot; title=&quot;关于 Block&quot;&gt;&lt;/a&gt;关于 Block&lt;/h3&gt;&lt;p&gt;在 iOS4.0之 后，block 横空出世，它本身封装了一段代码并将这段代码当做变量，通过 &lt;code&gt;block()&lt;/code&gt; 的方式进行回调。这不免让我们想到在C函数中，我们可以定义一个指向函数的指针并且调用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;executeSomeTask&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//do something and return if success or not&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; (*taskPoint)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;taskPoint = something;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOSDev" scheme="http://CalvinCheung.coding.me/categories/iOSDev/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>iOS 内存管理</title>
    <link href="http://CalvinCheung.coding.me/2017/07/03/iOS-Memory-Management-Reading-Notes/"/>
    <id>http://CalvinCheung.coding.me/2017/07/03/iOS-Memory-Management-Reading-Notes/</id>
    <published>2017-07-03T06:01:51.000Z</published>
    <updated>2019-03-02T11:04:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是自动引用计数-ARC"><a href="#什么是自动引用计数-ARC" class="headerlink" title="什么是自动引用计数(ARC)"></a>什么是自动引用计数(ARC)</h3><blockquote><p>在 Objective-C 中采用 <code>Automatic Reference Counting (ARC)</code> 机制，让编译器来进行内存管理。在新一代 Apple LLVM 编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>或者<code>release</code>代码，这在降低程序崩溃、内存泄漏等风险的问时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。</p></blockquote><a id="more"></a><h4 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>NSObject 类的源代码没有公开，此处利用 Xcode 的调试器和 iOS 大概追溯出其实现过程。</p><p>在 NSObject 类的 alloc 类方法上设置断点，追踪程序的执行。以下列出了执行所调用的方法和函数。</p><ul><li>+alloc</li><li>+allocWithZone:</li><li>class_createlnstance</li><li>calloc</li></ul><p>alloc 类方法首先调用 allocWithZone: 类方法，然后调用 <code>class_createlnstance</code> 函数，最后通过调用 <code>calloc</code> 来分配内存块。<code>class_createlnstance</code> 函数的源代码可以通过 <code>objc4</code> 库中的 <code>runtime/objc-runtime-new.mm</code> 进行确认。</p><p><code>retainCount/retain/release</code> 实例方法又是怎样实现的呢？同刚才的方法一样，下面列出各个方法分别调用的方法和函数。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-retainCount</div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashGetCountOfKey</span></div><div class="line"></div><div class="line">-<span class="keyword">retain</span></div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashAddValue</span></div><div class="line"></div><div class="line">-release</div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashRemoveValue</span></div><div class="line">(<span class="built_in">CFBasicHashRemoveValue</span> 返回 <span class="number">0</span> 时，-release 调用 dealloc )</div></pre></td></tr></table></figure><p>各个方法都通过同一个调用了 <code>_CFDoExternRefOperation</code> 函数，调用了一系列名称相似的函数。如这些函数名的前缀 “CF” 所示，它们包含于 <code>CoreFoundation</code> 框架源代码中，即是 <code>CFRuntime.c</code> 的 <code>_CFDoExternRefOperation</code> 函数。为了理解其实现，下面简化了<code>CFDoExternRefOperation</code> 函数后的源代码。</p><p><code>CF/CFRuntime.c</code> <code>_CFDoExternRefOperation</code></p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> _CFDoExternRefOperation ( uintptr_t op, <span class="keyword">id</span> obj ) &#123;</div><div class="line"></div><div class="line"><span class="built_in">CFBasicHashRef</span> table = 取得对象对应的散列表(obj);</div><div class="line"><span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(op)&#123;</div><div class="line">        <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        </div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="built_in">CFBasicHashAddValue</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>_CFDoExtemRefOperation</code> 函数按 <code>retainCount/retain/release</code> 操作进行分发，调用不同的函数。NSObject 类的 <code>retainCount/retain/release</code> 实例方法也许如下面代码所示：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>) _CFDoExternRefOperation (OPERATION_retainCount, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>) _CFDoExternRefOperation (OPERATION_retain, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _CFDoExternRefOperation(OPERATION_release, <span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以从 <code>_CFDoExternRefOperation</code> 函数以及由此函数调用的各个函数名看出，苹果的实现大概就是采用散列表（引用计数表）来管理引用计数。如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170703149905265688152.png" alt="20170703149905265688152.png"></p><p>通过引用计数表管理引用计数的好处如下:</p><ul><li>对象用内存块的分配无需考虑内存块头部。</li><li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块。</li></ul><p>这里特别要说的是，第二条这一特性在调试时有着举足轻重的作用。即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置。如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170703149905287931529.png" alt="20170703149905287931529.png"></p><p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p><p>通过以上解说即可理解苹果的实现。</p><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>autorelease 就是自动释放，这看上去很像 ARC，但实际上更类似于 C 语言中的自动变量的特性。</p><p>autorelease 会像 C 语言的自动变量那样来对待对象实例。当超出其作用域时，对象实例的 release 方法就会被调用。但和 C 语言的自动变量不同的是，程序员可以设定变量的作用域。</p><p>autorelease 具体使用方法如下：</p><ol><li>生成并持有 NSAutoreleasePool 对象</li><li>调用已分配对象的 autorelease 方法</li><li>废弃 NSAutoreleasePool 对象</li></ol><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170626149845880678893.png" alt="20170626149845880678893.png"></p><p>NSAutoreleasePool 对象的生命周期相当于 C 语言变量的作用域。对于所有调用过 autorelease 实例方法的对象，在废弃 NSAutoreleasePool 对象时，都将调用 release 实例方法。</p><p>用源码表示如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc]init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];</div></pre></td></tr></table></figure><p>上述代码中的 <code>[pool drain]</code> 相当于 <code>[obj release]</code>。</p><p>在 <code>Cocoa</code> 框架中，相当于程序主循环的 <code>NSRunLoop</code> 或者在其他程序可运行的地方，对 <code>NSAutoreleasePool</code> 对象进行生成、持有和废弃处理。因此，程序开发者不一定非得使用 <code>NSAutoreleasePool</code> 对象进行开发工作。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170626149846494350491.png" alt="20170626149846494350491.png"></p><p>尽管如此，但在大量产生 <code>autorelease</code> 的对象时，只要不废弃 <code>NSAutoreleasePool</code> 对象，那么生成的对象就不能释放，因此有时会产生内存不足的现象。典型的例子是读入大量图像的同时改变其尺寸。图像文件读入到 <code>NSData</code> 对象，并从中生成 <code>UIImage</code> 对象，改变其尺寸后生成新的 <code>UIImage</code> 对象。这种情况下，就会大量产生 <code>autorelease</code> 对象。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; 图像数;++i)&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    读入图像</span></div><div class="line"><span class="comment">    大量产生 autorelease 的对象</span></div><div class="line"><span class="comment">    由于没有废弃 NSAutoreleasePool 对象</span></div><div class="line"><span class="comment">    最终导致内存不足</span></div><div class="line"><span class="comment">    */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在此情况下，有必要在适当的地方生成、持有或废弃 <code>NSAutoreleasePool</code> 对象。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; 图像数;++i)&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc]init];</div><div class="line">    <span class="comment">// 读入图像，大量产生 autorelease 的对象</span></div><div class="line">    </div><div class="line">    [pool drain];</div><div class="line">    </div><div class="line">    <span class="comment">// 通过 [pool drain]，autorelease 的对象被一起 release</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，<code>Cocoa</code> 框架中也有很多类似方法用于返回 <code>autorelease</code> 的对象。比如 <code>NSMutableArray</code> 类的 <code>arrayWithCapacity</code> 类方法。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</div></pre></td></tr></table></figure><p>此源代码等同于以下源代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> array = [[[<span class="built_in">NSMutableArray</span> alloc]initWithCapacity:<span class="number">1</span>] autorelease];</div></pre></td></tr></table></figure><h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>可通过 <code>objc4</code> 库的 <code>runtime/objc-arr.mm</code> 来确认苹果中 <code>autorelease</code> 的实现。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push ()</div><div class="line">    &#123;</div><div class="line">        相当于生成或持有<span class="built_in">NSAutoreleasePool</span>类对象；</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *pop ( <span class="keyword">void</span> *token )</div><div class="line">    &#123;</div><div class="line">        相当于废弃<span class="built_in">NSAutoreleasePool</span>类对象；</div><div class="line">        releaseAll ();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease ( <span class="keyword">id</span> obj )</div><div class="line">    &#123;</div><div class="line">        相当于 `<span class="built_in">NSAutoreleasePool</span>` 类的 `addObject` 类方法</div><div class="line">        AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的AutoreleasePoolPage实例；</div><div class="line">        autoreleasePoolPage-&gt;add ( obj );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add (<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        将对象追加到内部数组中;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll ()</div><div class="line">    &#123;</div><div class="line">        调用内部数组中对象的release实例方法；</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop (<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop (ctxt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> *objc_autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease (obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C++ 类中虽然有动态数组的实现，但其行为和 GNUstep 的实现完全相同。</p><p>我们使用调试器来观察一下 <code>NSAutoreleasePool</code> 类方法和 <code>autorelease</code> 方法的运行过程。如下所示，这些方法调用了关联于 <code>objc4</code> 库 <code>autorelease</code> 实现的函数。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">/* 等同于 objc_autoreleasePoolPush ( ) */</span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"></div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">/* 等同于 objc_autorelease ( obj ) */</span></div><div class="line"></div><div class="line">[pool drain];</div><div class="line"><span class="comment">/* 等同于 objc_autoreleasePoolPop ( pool ) */</span></div></pre></td></tr></table></figure><p>另外，可通过 <code>NSAutoreleasePool</code> 类中的调试用非公开类方法 <code>showPools</code> 来确认己被 <code>autorelease</code> 的对象的状况。<code>showPools</code> 会将现在的 <code>NSAutoreleasePool</code> 的状况输出到控制台。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div></pre></td></tr></table></figure><p><code>NSAutoreleasePool</code> 类的 <code>showPools</code> 类方法只能在 iOS 中使用，作为替代，在现在的运行时系统中我们使用调试用非公开函数 _objc_autoreleasePoolPrint( )。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170703149905378046358.png" alt="20170703149905378046358.png"></p><hr><h4 id="提高调用Objective-C方法的速度"><a href="#提高调用Objective-C方法的速度" class="headerlink" title="提高调用Objective-C方法的速度"></a>提高调用Objective-C方法的速度</h4><p><code>GNUstep</code> 中的 <code>autorelease</code> 实际上是用一种特殊的方法来实现的。这种方法能够高效地运行0S X、iOS 用应用程序中频繁调用的 <code>autorelease</code> 方法，它被称为”IMP Caching”。</p><p>在进行方法调用时，为了解决类名/方法名以及取得方法运行时的函数指针，要在框架初始化时对其结果值进行缓存。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</div><div class="line">SEL autorelease_sel = <span class="keyword">@selector</span>(addObject:);</div><div class="line">IMP autorelease_imp =[autorelease_class methodForSelector:autorelease_sel];</div></pre></td></tr></table></figure><p>实际的方法调用就是使用缓存的结果值。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span> ) autorelease</div><div class="line">&#123;</div><div class="line">    (*autorelease_imp )( autorelease_class, autorelease_sel, <span class="keyword">self</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这就是 IMP Caching 的方法调用。虽然同以下源代码完全相同，但从运行效率上看，即使它依赖于运行环境，一般而言速度也是其他方法的2倍。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><h4 id="autorelease-NSAutoreleasePool-对象"><a href="#autorelease-NSAutoreleasePool-对象" class="headerlink" title="autorelease NSAutoreleasePool 对象"></a>autorelease NSAutoreleasePool 对象</h4><p>提问：如果 autorelease NSAutoreleasePool 对象会如何？</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"></div><div class="line">[pool autorelease];</div></pre></td></tr></table></figure><p>回答：发生异常</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException'</div><div class="line"></div><div class="line">reason: '*** -(NSAutoreleasePool autorelease]:</div><div class="line">    Cannot autorelease an autorelease pool<span class="string">'</span></div></pre></td></tr></table></figure><p>通常在使用 Objective-C,也就是 Foundation 框架时，无论调用哪一个对象的 autorelease 实例方法，实现上是调用的都是 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已被该类重载，因此运行时就会出错。</p><hr><h3 id="ARC-规则"><a href="#ARC-规则" class="headerlink" title="ARC 规则"></a>ARC 规则</h3><p>实际上”引用计数式内存管理”的本质部分在 ARC 中并没有改变。就像”自动引用计数”这个名称表示的那样，ARC 只是自动地帮组我们处理”引用计数”部分。</p><h4 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h4><p>引用计数式内存管理的思考方式就是思考 ARC 所引起的变化。</p><ul><li>自己生成的对象，自己所持有。</li><li>非自己生成的对象，自己也能持有。</li><li>自己持有的对象不再需要时释放。</li><li>非自己持冇的对象无法释放。</li></ul><p>这一思考方式在ARC有效时也是可行的。只是在源代码的记述方法上稍有不同。</p><h4 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h4><p><code>Objective-C</code> 编程中为了处理对象，可将变量类型定义为 id 类型或各种对象类型。</p><p>所谓对象类型就是指向 NSObject 这样的 Objective-C 类的指针，例如 “NSObject<em>“。id 类型用于隐藏对象类型的类名部分，相当于 C 语言中常用的 “void </em>“。</p><p>ARC 环境时，id 类型和对象类型同 C 语言其他类型不同，其类型上必须附加所有权修饰符。</p><p>所有权修饰符一共有4种。</p><ul><li>_strong 修饰符</li><li>_weak 修饰符</li><li>_unsafe_unretained 修饰符</li><li>_autoreleasing 修饰符</li></ul><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="_strong修饰符"></a>_strong修饰符</h5><p><code>_strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。也就是说，以下源代码中的 id 变量，实际上被附加了所有权修饰符。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>id 和对象类型在没有明确指定所有权修饰符时，默认为 <code>_strong</code> 修饰符。上面的源代码与以下相同。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>该源码在 MRC 环境该如何表述呢？</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* MRC */</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>该源代码一看则明，目前在表面上并没有任何变化。再看看下面的代码。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此源代码明确指定了 C 语言的变量的作用域。MRC 环境时，该源代码可记述如下:</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* MRC */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    [obj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了释放生成并持有的对象，增加了调用 <code>release</code> 方法的代码。该源代码进行的动作同先前 ARC 环境时的动作完全一样。</p><p>如此源代码所示，附有 <code>_strong</code> 修饰符的变量 obj 在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象。</p><p>如 “strong” 这个名称所示，<code>_strong</code> 修饰符表示对对象的 “强引用”。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p><p>当然，附有 <code>__strong</code> 修饰符的变量之间可以相互赋值。</p><p>正如苹果宣称的那样，通过 <code>__strong</code> 修饰符，不必再次键入 <code>retain</code> 或者 <code>release</code>,完美地满足了 “引用计数式内存管理的思考方式”：</p><ul><li>自己生成的对象，自己所持有。</li><li>非自己生成的对象，自己也能持有。</li><li>不再需要自己持有的对象时释放。</li><li>非自己持有的对象无法释放。</li></ul><p>前两项“自己生成的对象，自己持有”和“非自己生成的对象，自己也能持有”只需通过对带<code>_strong</code> 的修饰符的变景赋值便可达成。通过废弃带 <code>_strong</code> 修饰符的变量（变量作用域结束或是成员变量所属对象废弃）或者对变量赋值，都可以做到“不再需要自己持有的对象时释放”。</p><p>最后一项“非自己持有的对象无法释放”，由于不必再次键入 <code>release</code>,所以原本就不会执行。这些都满足于引用计数式内存管理的思考方式。</p><p>因为 id 类型和对象类型的所有权修饰符默认为 <code>_strong</code> 修饰符，所以不需要写上 “__strong”。使ARC 环境及简单的编程遵循了 Objective-C 内存管理的思考方式。</p><h5 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="_weak修饰符"></a>_weak修饰符</h5><p>看起来好像通过 <code>_strong</code> 修饰符编译器就能够完美地进行内存管理。但是遗憾的是，仅通过 <code>_strong</code> 修饰符是不能解决有些重大问题的。</p><p>这里提到的重大问题就是引用计数式内存管理中必然会发生”循环引用”的问题。</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170703149905469057068.png" alt="20170703149905469057068.png"></p><p>例如，前面出现的带有 <code>_strong</code> 修饰符的成员变量在持有对象时，很容易发生循环引用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">©interface Test : <span class="built_in">NSObject</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>以下为循环引用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];</div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];</div><div class="line">    [testO setObject:test1];</div><div class="line">    [test1 setObject:testO];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为便于理解，下面写出了生成并持有对象的状态。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    *test0持有Test对象A的强引用</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">/*对象A */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    *test1持有Test对象B的强引用</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">/*对象B */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Test对象A的obj_成员变置持有Test对象B的强引用。</span></div><div class="line"><span class="comment">    * 此时，持有Test对象B的强引用的变量为Test 对象 A 的 obj_和test1。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    [test0 setObject:test1];</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Test 对象 B 的 obj_ 成员变置持有 Test 对象 A 的强引用。</span></div><div class="line"><span class="comment">    * 此时，持有 Test 对象 A 的强引用的变置为 Test 对象 B 的 obj_ 和test0。</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    [testl setObject:test0];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 因为 test0 变置超出其作用域，强引用失效,</span></div><div class="line"><span class="comment">* 所以自动释放 Test 对象 A。</span></div><div class="line"><span class="comment">* 因为 testl 变置超出其作用域，强引用失效,</span></div><div class="line"><span class="comment">* 所以自动释放 Test 对象 B。</span></div><div class="line"><span class="comment">* 此时，持有 Test 对象 A 的强引用的变置为 Test 对象 B 的 obj_。</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* 此时，持有 Test 对象 B 的强引用的变置为 Test 对象 A 的 obj_。</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* 发生内存泄漏！</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><p>循环引用容易发生内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。此代码的本意是赋予变量 test0 的对象 A 和赋予变量 test1 的对象 B 在超出其变量作用域时被释放，即在对象不被任何变量持有的状态下予以废弃。但是，循环引用使得对象不能被再次废弃。</p><p>像下面这种情况，虽然只有一个对象，但在该对象持有其自身时，也会发生循环引用（自引用）。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> test = [[Test alloc] init];</div><div class="line">[test setObject:test];</div></pre></td></tr></table></figure><p>怎么样才能避免循环引用呢？看到 <code>_strong</code> 修饰符就会意识到了，既然有 <code>strong</code>,就应该有与之对应的 <code>weak</code>。也就是说，使用 <code>_weak</code> 修饰符可以避免循环引用。</p><p><code>_weak</code> 修饰符修饰符相反，提供弱引用。弱引用不能持有对象实例。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>变景 obj 上附加了 <code>_weak</code> 修饰符。实际上如果编译以下代码，编译器会发出聱告，</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">warning: assigning retained obj to <span class="keyword">weak</span> variable; obj will be</div><div class="line">    released after assignment [-Ware-unsafe-retained-<span class="keyword">assign</span>]</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div></pre></td></tr></table></figure><p>此源代码将自己生成并持有的对象赋值给附有 <code>_weak</code> 修饰符的变量 <code>obj</code>。即变量 <code>obj</code> 持有对持有对象的弱引用。因此，为了不以自己持有的状态来保存自己生成并持有的对象，生成的对象会立即被释放。编译器对此会给出警告。如果像下面这样，将对象赋值给附有 <code>_strong</code> 修饰符的变量之后再赋值给附有 <code>_weak</code> 修饰符的变量，就不会发生警告了。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = obj0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面确认对象的持有状况。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 自己生成并持有对象</span></div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    </div><div class="line">    <span class="comment">// 因为 obj0 变量为强引用，所以自己持有对象。</span></div><div class="line">    </div><div class="line">    <span class="comment">// obj1 变量持有生成对象的弱引用</span></div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = obj0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">    因为 obj0 变量超出其作用域，强引用失效，所以自动释放其持有的对象。</span></div><div class="line"><span class="comment">    因为对象的所有者不存在，所以废弃该对象。</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><p>因为带 <code>_weak</code> 修饰符的变量（即弱引用）不持有对象，所以在超出其变最作用域时，对象即被释放。如果像下面这样将先前可能发生循环引用的类成员变量改成附有 <code>_weak</code> 修饰符的成员变量的话，该现象便可避免。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170703149906419276443.png" alt="20170703149906419276443.png"></p><p><code>_weak</code> 修饰符还有另一优点。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil 被赋值的状态（空弱应用）。如以下代码所示。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    objl = obj0;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1);</div></pre></td></tr></table></figure><p>此源代码执行结果如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">A: &lt;<span class="built_in">NSObject</span>: <span class="number">0x753e</span>l80&gt;</div><div class="line">B: (null)</div></pre></td></tr></table></figure><p>像这样，使用 <code>_weak</code> 修饰符可避免循环引用,通过检查附有 <code>_weak</code> 修饰符的变量是否为nil，可以判断被赋值的对象是否己废弃。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>在 ARC 的环境下编译源代码，必须遵守一定的规则。下由就是具体的 ARC 的规则</p><ol><li>不能使用 retain/release/retainCount/autorelease</li><li>不能使用 NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不要显式调用 dealloc</li><li>使用 @autoreleasepool 块替代 NSAutoreleasePool</li><li>不能使用区域（NSZone)</li><li>对象型变量不能作为C语言结构体（struct/union)的成员</li><li>显式转换“id”和“void *”</li></ol><h4 id="不能使用-retain-release-retainCount-autorelease"><a href="#不能使用-retain-release-retainCount-autorelease" class="headerlink" title="不能使用 retain/release/retainCount/autorelease"></a>不能使用 retain/release/retainCount/autorelease</h4><p>内存管理是编译器的工作，因为没有必要使用内存管理的方法。</p><h4 id="不能使用-NSAllocateObject-NSDeallocateObject"><a href="#不能使用-NSAllocateObject-NSDeallocateObject" class="headerlink" title="不能使用 NSAllocateObject/NSDeallocateObject"></a>不能使用 NSAllocateObject/NSDeallocateObject</h4><p>一般通过调用 NSObject 类的 alloc 类方法来生成并持有 Objective-C 对象。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc];</div></pre></td></tr></table></figure><p>但是就如 GNUstep 的 alloc 实现所示，实际上是通过直接调用 <code>NSAllocateObject</code> 函数来生成并持有对象的。</p><p>在 ARC 环境时，禁止使用 <code>NSAllocateObject</code> 函数。同 <code>retain</code> 等方法一样，如果使用便会引起编译错误。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">error: 'NSAllocateObject is unavailable:</div><div class="line">not available <span class="keyword">in</span> automatic reference counting mode</div></pre></td></tr></table></figure><p>同样地，也禁止使用用于释放对象的 <code>NSDeallocateObject</code> 函数。</p><h4 id="须遵守内存管理的方法命名规则"><a href="#须遵守内存管理的方法命名规则" class="headerlink" title="须遵守内存管理的方法命名规则"></a>须遵守内存管理的方法命名规则</h4><p>在 MRC 环境时，用于对象生成/持有的方法必须遵守以下的命名规则。</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><p>以上述名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。这在 ARC 环境时也一样，返回的对象完全没有改变。只是在 ARC 环境下要追加一条命名规则。</p><ul><li>init</li></ul><p>以 init 开始的方法的规则要比 <code>alloc/new/copy/mutableCopy</code> 更严格。该方法必须是实例方法，并且必须要返回对象。返回的对象应为 id 类型或该方法声明类的对象类型，抑或是该类的超类型或子类型。该返回对象并不注册到 <code>autoreleasepool</code> 上。基本上只是对 <code>alloc</code> 方法返回值的对象进行初始化处理并返回该对象。</p><p>以下为使用该方法的源代码。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div></pre></td></tr></table></figure><p>如此源代码所示，init 方法会初始化 alloc 方法返回的对象，然后原封不动地返还给调用方。下面我们来看看以init开始的方法的命名规则。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span>) initWithObject:(<span class="keyword">id</span>)obj;</div></pre></td></tr></table></figure><p>该方法声明遵守了命名规则，但下面这个方法虽然也以init开始，却没有返回对象，因此不能使用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) initThisObject;</div></pre></td></tr></table></figure><p>另外，下例虽然也是以 init 开始的方法但并不包含在上述命名规则里。请注意。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) initialize;</div></pre></td></tr></table></figure><h4 id="不要显式调用-dealloc"><a href="#不要显式调用-dealloc" class="headerlink" title="不要显式调用 dealloc"></a>不要显式调用 dealloc</h4><p>无论 ARC 还是 MRC，只要对象的所有者都不持有该对象，该对象就被废弃。对象被废弃时，都会调用对象的 dealloc 方法</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 此处运行该对象被废弃时必须实现的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 MRC 环境下必须像下面这样调用 [super dealloc]</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 此处运行该对象被废弃时必须实现的代码</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ARC 会自动对此进行处理，因此不必写 [super dealloc]。 </p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在 ARC 环境下，Objective-C 类的属性也会发生变化。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) nsstring *name;</div></pre></td></tr></table></figure><p>在 ARC 环境下，以下可作为这种属性声明中使用的属性来用。</p><table><thead><tr><th>属性声明的属性</th><th>所有权修饰符</th></tr></thead><tbody><tr><td>assign</td><td>__unsafe_unretained 修饰符</td></tr><tr><td>copy</td><td>__strong修饰符(但是赋值的是被复制的对象)</td></tr><tr><td>retain</td><td>__strong 修饰符</td></tr><tr><td>strong</td><td>__strong 修饰符</td></tr><tr><td>unsafe_unretained</td><td>__unsafe_unretained 修饰符</td></tr><tr><td>weak</td><td>__weak 修饰符</td></tr></tbody></table><p>以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中。只有 <code>copy</code> 属性不是简单的斌值，它赋值的是通过 <code>NSCopying</code> 接口的<code>copyWithZone:</code> 方法复制赋值源所生成的对象。</p><p>另外，在声明类成员变量时，如果同属性声明中的属性不一致则会引起编译错误，比如下面这种情况。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj;</div></pre></td></tr></table></figure><p>在声明 id 型 obj 成员变量时，像下面这样，定义其属性声明为weak。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure><p>编译器出现如下错误。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">error: existing ivar 'obj' for _weak property 'obj' must be _weak</div><div class="line">    <span class="keyword">@synthesize</span> obj;</div><div class="line">    </div><div class="line">    note: property declared here</div><div class="line">    <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure><p>此时，成员变量的声明中需要附加 __weak 修饰符。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj;</div></pre></td></tr></table></figure><p>或者使用 <code>strong</code> 属性来代替 <code>weak</code> 属性。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, stong) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>以下是将附有 <code>_strong</code> 修饰符的变量作为静态数组使用的情况。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> objs[<span class="number">10</span>];</div></pre></td></tr></table></figure><p><code>_weak</code> 修饰符，<code>_autoreleasing</code> 修饰符以及 <code>_unsafe_unretained</code> 修饰符也与此相同。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> objs[<span class="number">10</span>];</div></pre></td></tr></table></figure><p><code>_unsafe_unretained</code> 修饰符以外的 _strong/_weak/ autorelcasing修饰符保证其指定的变量初始化为 nil。同样地，附有 _strong/_weak/_autoreleasing 修饰符变量的数组也保证其初始化为 nil。下面我们就来看看数组中使用附有 _strong 修饰符变量的例子：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> objs[<span class="number">2</span>];</div><div class="line"></div><div class="line">    objs[<span class="number">0</span>] = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    objs[l] = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>数组超出其变量作用域时，数组中各个附有 <code>_strong</code> 修饰符的变量也随之失效，其强引用消失，所赋值的对象也随之释放。这与不使用数组的情形完全一样。</p><p>将附有 _strong 修饰符的变量作为动态数组来使用时又如何呢？在这种情况下，根据不同的目的选择使用 NSMutableArray、NSMutableDictionary、NSMutableSet 等 Foundation 框架的容器。这些容器会恰当地持有追加的对象并为我们管理这些对象。</p><p>像这样使用容器虽然更为合适，但在 C 语言的动态数组中也可以使用附有 <code>_strong</code> 修饰符的变量，只是必须要遵守一些事项。以下按顺序说明。</p><p>声明动态数组用指针。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</div></pre></td></tr></table></figure><p>如前所述，由于 “id<em>“ 类型默认为 “id_autoreleasing</em>“ 类型，所以有必要显式指定为 <code>_strong</code> 修饰符。另外，虽然保证了附有 <code>_strong</code> 修饰符的 id 型变量被初始化为 nil,但并不保证附有 <code>_strong</code> 修饰符的 id 指针型变量被初始化为 nil。</p><p>另外，使用类名时如下记述。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> * _<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</div></pre></td></tr></table></figure><p>其次，使用 <code>calloc</code> 函数确保想分配的附有 <code>_strong</code> 修饰符变量的容量占有的内存块。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array = (<span class="keyword">id</span> __<span class="keyword">strong</span> *) calloc(entries, <span class="keyword">sizeof</span>(<span class="keyword">id</span>));</div></pre></td></tr></table></figure><p>该源代码分配了 <code>entries</code> 个所需的内存块。由于使用附有 <code>_strong</code> 修饰符的变量前必须先将<br>其初始化为 nil，所以这里使用使分配区域初始化为0的 <code>calloc</code> 函数来分配内存。不使用 <code>calloc</code> 函<br>数，在用 <code>malloc</code> 函数分配内存后可用 <code>memset</code> 等函数将内存填充为0。</p><p>但是，像下面的源代码这样，将 nil 代入到 malloc 函数所分配的数组各元素中来初始化是非常危险的。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array = (<span class="keyword">id</span> _<span class="keyword">strong</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">id</span>) * entries);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i * <span class="number">0</span>; i &lt; entries; ++i)</div><div class="line">    array[i] = <span class="literal">nil</span>;</div></pre></td></tr></table></figure><p>这是因为由于 malloc 函数分配的内存区域没有被初始化为0，因此 nil 会被赋值给附有 <code>_strong</code> 修饰符的并被赋值了随机地址的变量中，从而释放一个不存在的对象。在分配内存时推荐使用 calloc 函数。</p><p>像这样，通过 calloc 函数分配的动态数组就能完全像静态数组一样使用。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array[<span class="number">0</span>] = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure><p>但是，在动态数组中操作附有 <code>_strong</code> 修饰符的变量与静态数组有很大差异，需要自己释放所有的元素。</p><p>如以下源代码所示，在只是简单地用 <code>free</code> 函数废弃了数组用内存块的情况下，数组各元素所赋值的对象不能再次释放，从而引起内存泄漏。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">free(array);</div></pre></td></tr></table></figure><p>这是因为在静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，而在动态数组中，编译器不能确定数组的生存周期，所以无从处理。如以下源代码所示，一定要将 nil 赋值给所有元素中，使得元素所赋值对象的强引用失效，从而释放那些对象。在此之后，使用 <code>free</code> 函数废弃内存块。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i * <span class="number">0</span>; i &lt; entries; ++i)</div><div class="line">    array[i] = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">free(array);</div></pre></td></tr></table></figure><p>同初始化时的注意事项相反，即使用 memset 等函数将内存填充为0也不会释放所赋值的对象。这非常危险，只会引起内存泄漏。对于编译器，必须明确地使用赋值给附有 <code>_strong</code> 修饰符变量的源代码。所以请注意，必须将 nil 赋值给所有数组元素。</p><p>另外，使用 <code>memcpy</code> 函数拷贝数组元素以及 <code>realloc</code> 函数重新分配内存块也会有危险，由于数组元素所赋值的对象有可能被保留在内存中或是重复被废弃，所以这两个函数也禁止使用。</p><p>再者，我们也可以像使用 <code>_strong</code> 修饰符那样使用附有 <code>_weak</code> 修饰符变量的动态数组。在 <code>_autoreleasing</code> 修饰符的情况下，因为与设想的使用方法有差异，所以最好不要使用动态数组。由于<code>_unsafe_unretained</code> 修饰符在编译器的内存管理对象之外，所以它与 void* 类型一样，只能作为C语言的指针类型来使用。</p><p>本文是根据<a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C高级编程</a>第一章整理，作学习和参考之用</p><p>关于内存管理可以查看一下唐巧大神博客的讲解：<br><a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="external">理解 iOS 的内存管理-唐巧</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是自动引用计数-ARC&quot;&gt;&lt;a href=&quot;#什么是自动引用计数-ARC&quot; class=&quot;headerlink&quot; title=&quot;什么是自动引用计数(ARC)&quot;&gt;&lt;/a&gt;什么是自动引用计数(ARC)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在 Objective-C 中采用 &lt;code&gt;Automatic Reference Counting (ARC)&lt;/code&gt; 机制，让编译器来进行内存管理。在新一代 Apple LLVM 编译器中设置ARC为有效状态，就无需再次键入&lt;code&gt;retain&lt;/code&gt;或者&lt;code&gt;release&lt;/code&gt;代码，这在降低程序崩溃、内存泄漏等风险的问时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://CalvinCheung.coding.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
  <entry>
    <title>Swift CoreAnimation:CATransition 转场动画</title>
    <link href="http://CalvinCheung.coding.me/2017/07/02/Swift-Animation10/"/>
    <id>http://CalvinCheung.coding.me/2017/07/02/Swift-Animation10/</id>
    <published>2017-07-02T07:50:54.000Z</published>
    <updated>2019-03-02T11:02:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>CATransition 同 CoreAnimation 核心动画中 CABasicAnimation 等相关类的使用方法类似。主要分为三个步骤：</p><p>（1）实例化 CATransition，并设置相应的转场动画 key。<br>（2）设置合适的转场动画属性，比如动画时间、过渡方向、动画保持状态等。<br>（3）将动画效果添加到对应视图的 Layer 图层中。</p><a id="more"></a><h3 id="CATransition-转场动画效果合集"><a href="#CATransition-转场动画效果合集" class="headerlink" title="CATransition 转场动画效果合集"></a>CATransition 转场动画效果合集</h3><p>例如：基于 CATransition 的图片查看器</p><p>先初始化一张图片视图和按钮</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> imageView:<span class="type">UIImageView</span>?</div><div class="line"><span class="keyword">var</span> animBtn:<span class="type">UIButton</span>?</div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewDidLoad()</div><div class="line">   imageView = <span class="type">UIImageView</span>()</div><div class="line">   imageView?.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">300</span>, height: <span class="number">400</span>)</div><div class="line">   imageView?.center = <span class="keyword">self</span>.view.center</div><div class="line">   imageView?.image = <span class="type">UIImage</span>(named: <span class="string">"1.jpg"</span>)</div><div class="line">   imageView?.contentMode = <span class="type">UIViewContentMode</span>.scaleAspectFit</div><div class="line">   <span class="keyword">self</span>.view.addSubview(imageView!)</div><div class="line">   </div><div class="line">   animBtn = <span class="type">UIButton</span>()</div><div class="line">   animBtn?.frame = <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">30</span>, width: <span class="number">80</span>, height: <span class="number">44</span>)</div><div class="line">   animBtn?.backgroundColor = <span class="type">UIColor</span>.red</div><div class="line">   animBtn?.setTitle(<span class="string">"AnimBtn"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</div><div class="line">   animBtn?.setTitleColor(<span class="type">UIColor</span>.white, <span class="keyword">for</span>: <span class="type">UIControlState</span>.normal)</div><div class="line">   animBtn?.addTarget(<span class="keyword">self</span>, action: #selector(animBtnClick), <span class="keyword">for</span>: <span class="type">UIControlEvents</span>.touchUpInside)</div><div class="line">   <span class="keyword">self</span>.view.addSubview(animBtn!)</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实现按钮的点击事件和动画效果,一次使用一个效果即可</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animBtnClick</span><span class="params">()</span></span> &#123; </div><div class="line">   imageView?.image = <span class="type">UIImage</span>(named: <span class="string">"2.jpg"</span>)</div><div class="line">   <span class="keyword">let</span> animation:<span class="type">CATransition</span> = <span class="type">CATransition</span>()</div><div class="line">   animation.duration = <span class="number">2</span>;</div><div class="line">   animation.type = <span class="string">"oglFlip"</span> <span class="comment">// 翻转效果</span></div><div class="line">   animation.type = <span class="string">"cube"</span> <span class="comment">// 立方体效果</span></div><div class="line">   animation.type = <span class="string">"stuckEffect"</span> <span class="comment">// 收缩效果</span></div><div class="line">   animation.type = <span class="string">"rippleEffect"</span> <span class="comment">// 水滴波纹效果</span></div><div class="line">   animation.type = <span class="string">"pageUnCurl"</span>  <span class="comment">// 向下翻页</span></div><div class="line">   animation.type = <span class="string">"pageCurl"</span> <span class="comment">// 向上翻页</span></div><div class="line">   animation.type = <span class="string">"cameraIrisHollowOpen"</span> <span class="comment">// 相机打开</span></div><div class="line">   animation.type = <span class="string">"cameraIrisHollowClose"</span> <span class="comment">// 相机关闭</span></div><div class="line">   animation.type = kCATransitionFade <span class="comment">// 淡入淡出</span></div><div class="line">   animation.type = kCATransitionPush <span class="comment">// 推送效果</span></div><div class="line">   animation.type = kCATransitionReveal <span class="comment">// 揭开效果</span></div><div class="line">   animation.type = kCATransitionMoveIn <span class="comment">// 移动效果</span></div><div class="line">   animation.subtype = kCATransitionFromRight</div><div class="line">   <span class="keyword">self</span>.view.layer.add(animation, forKey: <span class="literal">nil</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="视图过渡动画"><a href="#视图过渡动画" class="headerlink" title="视图过渡动画"></a>视图过渡动画</h3><h4 id="视图控制器过渡动画相关协议"><a href="#视图控制器过渡动画相关协议" class="headerlink" title="视图控制器过渡动画相关协议"></a>视图控制器过渡动画相关协议</h4><p>（1）UINavigationControllerDelegate<br>（2）UIViewControllerAnimatedTransitioning</p><p>UINavigationControllerDelegate 是视图控制器使用的委托代理协议，该协议可以代理视图的以下功能：</p><p>（1）拦截导航栏视图控制器<br>（2）拦截视图控制器目标 ViewController 和源 ViewController。</p><p>在过渡动画中将使用 UINavigationControllerDelegate 的第二个功能，即拦截视图控制器目标 ViewController 和源 ViewController。该功能的回调方法如下所示：</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>?&#123;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在该方法中 formVC 表明该视图控制器在跳转过程中来自哪个视图控制器。toVC 表明该视图控制器在跳转过程中最终跳转到何处去。所以只要拿到这两个视图控制器，在其上的 View 图层中添加想要实现的动画即可实现转场过渡动画效果。</p><p>实际上以上所有的动画操作都将借助于 <code>UIViewControllerAnimatedTransitioning</code>  协议，将所有的动画效果最终封装成一个实例对象返回给视图控制器 <code>UIViewController-AnimatedTransitioning</code> 协议，定义了视图过渡动画的执行周期和执行内容。</p><p>它有两个非常重要的回调方法。</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span></div></pre></td></tr></table></figure><p><code>transitionDuration</code> 方法返回转场动画执行周期。</p><p><code>animateTransition</code> 方法用于构建转场动画内容。在该方法中可以通过 <code>transitionContext</code> 属性获取当前的 <code>fromViewController</code> 和 <code>toViewController</code>。拿到这两个视图控制器后就可以设置当前视图控制器的各种动画效果。</p><h4 id="视图控制器过渡动画实现"><a href="#视图控制器过渡动画实现" class="headerlink" title="视图控制器过渡动画实现"></a>视图控制器过渡动画实现</h4><p>第一步：实现当前页面 ViewController.swift 内容</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> viewcontroller:<span class="type">NewViewController</span> = <span class="type">NewViewController</span>()</div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewDidLoad()</div><div class="line">   <span class="keyword">self</span>.title = <span class="string">"Main Viewcontroller"</span>;</div><div class="line">   <span class="keyword">self</span>.view.backgroundColor = <span class="type">UIColor</span>.blue</div><div class="line">   navigationController!.delegate = <span class="keyword">self</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(<span class="number">_</span> navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span>?&#123;</div><div class="line">   <span class="keyword">let</span> transitionAnim:<span class="type">TransitionAnim</span> = <span class="type">TransitionAnim</span>()</div><div class="line">   <span class="keyword">return</span> transitionAnim</div><div class="line">&#125;</div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class="line">   <span class="keyword">self</span>.navigationController?.pushViewController(viewcontroller, animated: <span class="literal">false</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二步：实现下一页面 NewViewController.swift 内容</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewDidLoad()</div><div class="line">   <span class="keyword">self</span>.view.backgroundColor = <span class="type">UIColor</span>.red</div><div class="line">   <span class="keyword">self</span>.title = <span class="string">"New Viewcontroller"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第三步：实现视图控制器转场动画。这里实现一个从下到上的推出动画效果。TransitionAnim.swift 内容如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionAnim</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span>&#123;</div><div class="line">       <span class="keyword">let</span> fromVC:<span class="type">UIViewController</span> = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.from)!</div><div class="line">       <span class="keyword">let</span> toVC:<span class="type">UIViewController</span> = transitionContext.viewController(forKey: <span class="type">UITransitionContextViewControllerKey</span>.to)!</div><div class="line">       <span class="keyword">let</span> fromVCRect = transitionContext.initialFrame(<span class="keyword">for</span>: fromVC)</div><div class="line">       <span class="keyword">let</span> toVCRect = <span class="type">CGRect</span>(x: <span class="number">0</span>,y: fromVCRect.size.height*<span class="number">2</span>,width: fromVCRect.size.width,height: fromVCRect.size.height)</div><div class="line">       <span class="keyword">let</span> fromView:<span class="type">UIView</span> = fromVC.view</div><div class="line">       <span class="keyword">let</span> toView:<span class="type">UIView</span> = toVC.view</div><div class="line">       fromView.frame = fromVCRect</div><div class="line">       toView.frame = toVCRect</div><div class="line">       transitionContext.containerView.addSubview(fromView)</div><div class="line">       transitionContext.containerView.addSubview(toView)</div><div class="line">    </div><div class="line">       <span class="type">UIView</span>.animate(withDuration: <span class="number">2</span>, animations: &#123; () <span class="keyword">in</span></div><div class="line">           toView.frame = fromVCRect;</div><div class="line">           toView.alpha = <span class="number">1</span>;</div><div class="line">           &#125;, completion: &#123; (<span class="type">Bool</span>) <span class="keyword">in</span></div><div class="line">           transitionContext.completeTransition(<span class="literal">true</span>)</div><div class="line">       &#125;)</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2017070214989864082214.gif" alt="2017070214989864082214.gif"></p><h3 id="侧滑栏动画"><a href="#侧滑栏动画" class="headerlink" title="侧滑栏动画"></a>侧滑栏动画</h3><p>参考网上的一些新闻类应用，发现在侧滑栏动画实现的同时还具有蒙版或者模糊效果，所以在这个案例中将动画分为2个部分，第一部分为蒙版模糊效果，第二部分为侧滑滑出以及收起效果。</p><p>第一部分：蒙版模糊效果</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">blurimageFromImage</span><span class="params">(<span class="number">_</span> image:UIImage)</span></span>-&gt;<span class="type">UIImage</span>&#123;</div><div class="line">   <span class="keyword">let</span> blurRadix:<span class="type">UInt32</span> = <span class="number">7</span></div><div class="line">   <span class="keyword">let</span> img:<span class="type">CGImage</span> = image.cgImage!</div><div class="line">   <span class="keyword">let</span> inProvider:<span class="type">CGDataProvider</span> = img.dataProvider!</div><div class="line">   <span class="keyword">let</span> bitmapdata:<span class="type">CFData</span> = inProvider.data!</div><div class="line">   </div><div class="line">   <span class="keyword">var</span> inputBuffer:vImage_Buffer = vImage_Buffer()</div><div class="line">   inputBuffer.data=(<span class="type">UnsafeMutableRawPointer</span>)(<span class="keyword">mutating</span>: <span class="type">CFDataGetBytePtr</span>(bitmapdata))</div><div class="line">   inputBuffer.width=(vImagePixelCount)(img.width)</div><div class="line">   inputBuffer.height=(vImagePixelCount)(img.height)</div><div class="line">   inputBuffer.rowBytes=img.bytesPerRow;</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> pixelBuffer:<span class="type">UnsafeMutableRawPointer</span> = malloc(img.bytesPerRow * img.height);</div><div class="line">   </div><div class="line">   <span class="keyword">var</span> outputBuffer:vImage_Buffer = vImage_Buffer()</div><div class="line">   outputBuffer.data=pixelBuffer</div><div class="line">   outputBuffer.width=(vImagePixelCount)(img.width)</div><div class="line">   outputBuffer.height=(vImagePixelCount)(img.height)</div><div class="line">   outputBuffer.rowBytes=img.bytesPerRow;</div><div class="line">   </div><div class="line">   vImageBoxConvolve_ARGB8888(&amp;inputBuffer, &amp;outputBuffer, <span class="literal">nil</span>, <span class="number">0</span>, <span class="number">0</span>, blurRadix, blurRadix, <span class="literal">nil</span>, <span class="type">UInt32</span>(kvImageEdgeExtend))</div><div class="line"></div><div class="line">   <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> w:<span class="type">Int</span>=(<span class="type">Int</span>)(outputBuffer.width)</div><div class="line">   <span class="keyword">let</span> h:<span class="type">Int</span>=(<span class="type">Int</span>)(outputBuffer.height)</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> ctx:<span class="type">CGContext</span> = <span class="type">CGContext</span>(data: outputBuffer.data, width: w, height: h, bitsPerComponent: <span class="number">8</span>, bytesPerRow: outputBuffer.rowBytes, space: colorSpace, bitmapInfo: image.cgImage!.bitmapInfo.rawValue)!</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> imageRef:<span class="type">CGImage</span> = ctx.makeImage ()!</div><div class="line">   <span class="keyword">let</span> imagenew:<span class="type">UIImage</span> = <span class="type">UIImage</span>(cgImage:imageRef)</div><div class="line">   </div><div class="line">   free(pixelBuffer)</div><div class="line">   </div><div class="line">   <span class="keyword">return</span> imagenew;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">imageFromUIView</span><span class="params">(<span class="number">_</span> view:UIView)</span></span>-&gt;<span class="type">UIImage</span>&#123;</div><div class="line">   <span class="type">UIGraphicsBeginImageContext</span>(view.frame.size)</div><div class="line">   <span class="keyword">let</span> content:<span class="type">CGContext</span> = <span class="type">UIGraphicsGetCurrentContext</span>()!</div><div class="line">   view.layer.render(<span class="keyword">in</span>: content)</div><div class="line">   <span class="keyword">let</span> imagenew:<span class="type">UIImage</span> = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()!;</div><div class="line">   <span class="type">UIGraphicsEndImageContext</span>();</div><div class="line">   <span class="keyword">return</span> imagenew</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二部分：侧滑初始化</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Accelerate</div><div class="line"><span class="keyword">let</span> <span class="type">DEVICE_SCREEN_HEIGHT</span> = <span class="type">UIScreen</span>.main.bounds.height</div><div class="line"><span class="keyword">let</span> <span class="type">DEVICE_SCREEN_WIDTH</span> = <span class="type">UIScreen</span>.main.bounds.width</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliderViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> blurView:<span class="type">UIView</span>?</div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> contentView:<span class="type">UIView</span>?</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.viewDidLoad()</div><div class="line">        blurView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>))</div><div class="line">        <span class="keyword">self</span>.view.addSubview(blurView!)</div><div class="line">        contentView = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: -<span class="type">DEVICE_SCREEN_WIDTH</span>*<span class="number">0.60</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>*<span class="number">0.60</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>))</div><div class="line">        contentView!.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">255.0</span> / <span class="number">255.0</span>, green: <span class="number">127.0</span> / <span class="number">255.0</span>, blue: <span class="number">79.0</span> / <span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</div><div class="line">        <span class="keyword">self</span>.view.addSubview(contentView!)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>侧滑栏收起效果</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliderVCDismiss</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;()-&gt;<span class="type">Void</span> <span class="keyword">in</span></div><div class="line">       <span class="keyword">self</span>.contentView!.frame = <span class="type">CGRect</span>(x: -<span class="type">DEVICE_SCREEN_WIDTH</span>*<span class="number">0.6</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>*<span class="number">0.6</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>)</div><div class="line">       <span class="keyword">self</span>.contentView!.alpha = <span class="number">0.9</span></div><div class="line">       &#125;, completion: &#123;(finished:<span class="type">Bool</span>)-&gt;<span class="type">Void</span> <span class="keyword">in</span></div><div class="line">           <span class="keyword">self</span>.view.alpha=<span class="number">0.0</span></div><div class="line">   &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>侧滑栏弹出动画</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliderLeftViewAnimStart</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> windowview:<span class="type">UIView</span> = <span class="type">UIView</span>()</div><div class="line">   windowview = <span class="type">UIApplication</span>.shared.keyWindow!.rootViewController!.view</div><div class="line">   </div><div class="line">   blurView?.layer.contents = blurimageFromImage(imageFromUIView(windowview)).cgImage</div><div class="line">   <span class="keyword">self</span>.view.alpha=<span class="number">1.0</span></div><div class="line">   <span class="type">UIView</span>.animate(withDuration: <span class="number">0.5</span>, animations: &#123;()-&gt;<span class="type">Void</span> <span class="keyword">in</span></div><div class="line">       <span class="keyword">self</span>.contentView!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>*<span class="number">0.6</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>)</div><div class="line">       <span class="keyword">self</span>.contentView!.alpha = <span class="number">0.9</span></div><div class="line">       &#125;, completion: &#123;(finished:<span class="type">Bool</span>)-&gt;<span class="type">Void</span> <span class="keyword">in</span></div><div class="line">   &#125;)</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 ViewController 中进行调用</p><figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pushSliderVC:<span class="type">Bool</span> = <span class="literal">true</span></div><div class="line"><span class="keyword">var</span> sliderVC:<span class="type">SliderViewController</span> = <span class="type">SliderViewController</span>()</div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">   <span class="keyword">super</span>.viewDidLoad()</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> imageView:<span class="type">UIImageView</span> = <span class="type">UIImageView</span>(frame:<span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>))</div><div class="line">   imageView.image = <span class="type">UIImage</span>(named: <span class="string">"login.png"</span>)</div><div class="line">   <span class="keyword">self</span>.view.addSubview(imageView)</div><div class="line">   </div><div class="line">   <span class="keyword">let</span> loginButton:<span class="type">UIButton</span> = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">20</span>, y: <span class="number">230</span>, width: <span class="keyword">self</span>.view.frame.width-<span class="number">20</span>*<span class="number">2</span>,height: <span class="number">50</span>))</div><div class="line">   loginButton.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">50</span>/<span class="number">255.0</span>, green: <span class="number">185</span>/<span class="number">255.0</span>, blue: <span class="number">170</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</div><div class="line">   loginButton.setTitle(<span class="string">"登陆"</span>, <span class="keyword">for</span>: <span class="type">UIControlState</span>())</div><div class="line">   <span class="keyword">self</span>.view.addSubview(loginButton)</div><div class="line">   </div><div class="line">   </div><div class="line">   sliderVC.view.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">DEVICE_SCREEN_WIDTH</span>, height: <span class="type">DEVICE_SCREEN_HEIGHT</span>)</div><div class="line">   sliderVC.view.isHidden=<span class="literal">true</span></div><div class="line">   <span class="keyword">self</span>.view.addSubview(sliderVC.view)</div><div class="line">   </div><div class="line">&#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</div><div class="line">   <span class="keyword">if</span> pushSliderVC &#123;</div><div class="line">       sliderVC.view.isHidden = <span class="literal">false</span></div><div class="line">       sliderVC.sliderLeftViewAnimStart()</div><div class="line">   &#125;<span class="keyword">else</span>&#123;</div><div class="line">       sliderVC.view.isHidden = <span class="literal">true</span></div><div class="line">       sliderVC.sliderVCDismiss()</div><div class="line">   &#125;</div><div class="line">   pushSliderVC = !pushSliderVC</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最终效果如下：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170702149898782468814.gif" alt="20170702149898782468814.gif"></p><p>全文代码：<a href="https://github.com/CalvinCheungCoder/SwiftAnimation/tree/master/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB" target="_blank" rel="external">点击查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CATransition 同 CoreAnimation 核心动画中 CABasicAnimation 等相关类的使用方法类似。主要分为三个步骤：&lt;/p&gt;
&lt;p&gt;（1）实例化 CATransition，并设置相应的转场动画 key。&lt;br&gt;（2）设置合适的转场动画属性，比如动画时间、过渡方向、动画保持状态等。&lt;br&gt;（3）将动画效果添加到对应视图的 Layer 图层中。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://CalvinCheung.coding.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="http://CalvinCheung.coding.me/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发之 Widget 的实现</title>
    <link href="http://CalvinCheung.coding.me/2017/06/29/iOSDev-widget/"/>
    <id>http://CalvinCheung.coding.me/2017/06/29/iOSDev-widget/</id>
    <published>2017-06-29T12:18:21.000Z</published>
    <updated>2019-03-02T11:04:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="添加-Today-Extension-工程"><a href="#添加-Today-Extension-工程" class="headerlink" title="添加 Today Extension 工程"></a>添加 Today Extension 工程</h3><p>在原有的项目基础上，想要使用 <code>Today Extension</code>，即 <code>Widget</code>。我们需要创建一个新的 <code>target</code>，点击<code>File--&gt;New--&gt;Target--&gt;Today Extention</code>，如下图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149873901496022.png" alt="20170629149873901496022.png"></p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2017062914987390541464.png" alt="2017062914987390541464.png"></p><a id="more"></a><p>创建成功后如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149873913639399.png" alt="20170629149873913639399.png"></p><p>此时直接运行项目，如下图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149873922219531.png" alt="20170629149873922219531.png"></p><h3 id="Widget-UI-简单实现"><a href="#Widget-UI-简单实现" class="headerlink" title="Widget UI 简单实现"></a>Widget UI 简单实现</h3><p>本人习惯使用纯代码布局，所以我删除了默认创建的 <code>MainInterface.storyboard</code>，并在<code>info.plist</code> 中删除 <code>NSExtensionMainStoryboard</code> 字段，添加<code>NSExtensionPrincipalClass</code> 为 <code>TodayViewController</code>，如下图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/2017062914987393879662.png" alt="2017062914987393879662.png"></p><p>当然，如果你习惯使用 <code>xib</code> 或者 <code>storyboard</code> 布局的话，可以直接在 <code>MainInterface.storyboard</code> 文件中进行 UI 实现。</p><p>实现下面的协议，配置 <code>widget</code> 的边距，否则你会发现 UI 的位置会与左侧边界有一定距离。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">UIEdgeInsets</span>)widgetMarginInsetsForProposedMarginInsets:(<span class="built_in">UIEdgeInsets</span>)defaultMarginInsets &#123;</div><div class="line">    <span class="comment">// 配置边距为0</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后初始化一个 UILabel 显示未登录的提示，并给 UILabel 添加一个点击事件，使点击后能够打开 App 的登录页面。代码如下:</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">self</span>.loginInLabel = [[<span class="built_in">UILabel</span> alloc] init];</div><div class="line"><span class="keyword">self</span>.loginInLabel.textColor = [<span class="built_in">UIColor</span> colorWithRed:(<span class="number">214.0</span>/<span class="number">255.0</span>) green:(<span class="number">33.0</span>/<span class="number">255.0</span>) blue:(<span class="number">25.0</span>/<span class="number">255.0</span>) alpha:<span class="number">1</span>];</div><div class="line"><span class="keyword">self</span>.loginInLabel.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</div><div class="line"><span class="keyword">self</span>.loginInLabel.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width<span class="number">-16</span>, <span class="number">90</span>);</div><div class="line"><span class="keyword">self</span>.loginInLabel.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</div><div class="line"><span class="keyword">self</span>.loginInLabel.text = <span class="string">@"未登录,点击登录账户"</span>;</div><div class="line"><span class="keyword">self</span>.loginInLabel.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">20</span>];</div><div class="line"><span class="keyword">self</span>.loginInLabel.userInteractionEnabled = <span class="literal">YES</span>;</div><div class="line">  </div><div class="line"><span class="built_in">UITapGestureRecognizer</span> *openURLContainingAPP = [[<span class="built_in">UITapGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(openURLContainingAPP)];</div><div class="line">[<span class="keyword">self</span>.loginInLabel addGestureRecognizer:openURLContainingAPP];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.loginInLabel];</div></pre></td></tr></table></figure><p>当然，widget 的 UI 实现是根据具体的业务来进行实现的，此处只是举例。</p><h3 id="Widget-的展开和折叠"><a href="#Widget-的展开和折叠" class="headerlink" title="Widget 的展开和折叠"></a>Widget 的展开和折叠</h3><p>在<code>NSExtensionContext</code>中，有<code>widgetLargestAvailableDisplayMode</code>属性，来确认当前<code>widget</code>是展开还是折叠状态。所以，我们可以先在<code>viewWillAppear</code>中设置<code>widget</code>的<code>mode</code>。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</div><div class="line">    <span class="keyword">self</span>.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeExpanded;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后，就是展开和折叠的处理了。在<code>NCWidgetProviding</code>协议中，有<code>widgetActiveDisplayModeDidChange</code>方法</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(<span class="built_in">CGSize</span>)maxSize &#123;</div><div class="line">    <span class="keyword">if</span> (activeDisplayMode == NCWidgetDisplayModeCompact) &#123;</div><div class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="built_in">CGSizeMake</span>([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">110</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.preferredContentSize = <span class="built_in">CGSizeMake</span>([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">300</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里需要注意的是，Widget 的折叠和展开时的高度不是可以随便设置的。在 <code>widgetActiveDisplayModeDidChange</code> 协议方法里可以打印出<br><code>withMaximumSize</code></p><p>其中在 5s 模拟器下:</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">NCWidgetDisplayModeCompact模式下:&#123;<span class="number">304</span>, <span class="number">110</span>&#125;</div><div class="line">NCWidgetDisplayModeExpanded模式下:&#123;<span class="number">304</span>, <span class="number">528</span>&#125;</div></pre></td></tr></table></figure><p>6s模拟器下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">NCWidgetDisplayModeCompact模式下:&#123;<span class="number">359</span>, <span class="number">110</span>&#125;</div><div class="line">NCWidgetDisplayModeExpanded模式下:&#123;<span class="number">359</span>, <span class="number">616</span>&#125;</div></pre></td></tr></table></figure><p>从上面的限制可知，widget 在折叠状态下最低为110，最高也根据机型有最大限制。注意处理好折叠和展开时 widget UI 和数据的变化，在此不做赘述。</p><h3 id="点击-Widget-进入-App"><a href="#点击-Widget-进入-App" class="headerlink" title="点击 Widget 进入 App"></a>点击 Widget 进入 App</h3><p>刚才我们在 <code>widget</code> 中添加了一个充满折叠视图的 <code>UILabel</code>，并想在用户点击时直接打开 App 的登录页面。</p><p>这里我们要设置一下 <code>URL Schemes</code> ,<code>URL Schemes</code> 主要作用是 App 之间相互调用打开，包括我们在实现第三方分享、第三方登录时都需要用到 <code>URL Schemes</code>。</p><p>如图所示，在 <code>info -&gt; URL Types</code> 里设置好 <code>Schemes</code> 后</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874119223815.png" alt="20170629149874119223815.png"></p><p>再在 <code>Today Extention</code>  对应的 <code>info.plist</code> 里设置 <code>Schemes</code>,如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874139991858.png" alt="20170629149874139991858.png"></p><p>设置好 Schemes 后，实现 UILabel 的点击事件：</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过 openURL 的方式启 APP</span></div><div class="line">- (<span class="keyword">void</span>)openURLContainingAPP</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.extensionContext openURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"xiaozhumi://"</span>]</div><div class="line">                 completionHandler:^(<span class="built_in">BOOL</span> success) &#123;</div><div class="line">                     <span class="built_in">NSLog</span>(<span class="string">@"open url result:%d"</span>,success);</div><div class="line">                 &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此时我们可以处理点击事件，让用户点击后直接打开 App 的登录页面并登录。</p><p>当用户登录成功后再次查看 widget 时，这时候如果继续显示登录的提示显然是不妥的，此时根据业务需求，我需要在用户登录账号成功后再次查看 widget 时，widget 展示用户的个人积分。</p><h3 id="App-和-Widget-的数据共享"><a href="#App-和-Widget-的数据共享" class="headerlink" title="App 和 Widget 的数据共享"></a>App 和 Widget 的数据共享</h3><p>由于沙盒机制，拓展应用是不允许访问宿主应用的沙盒路径的，因此上述用法是不对的，需要搭配 app group完成实例化 UserDefaults。</p><p>首先需要去苹果开发者中心 <code>Identifiers -&gt; APP Groups</code> 中创建一个 <code>APP Group</code>，命名方式 <code>group.com.companyName.xxx</code>，如下图</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874199157137.png" alt="20170629149874199157137.png"></p><p>当创建好 <code>App Group</code> 后，分别在 主项目和 <code>Today</code> 的 <code>Capabilities</code> 设置选项中打开 <code>App Group</code> 选项，并选中在苹果开发者中心设置的 <code>App Group</code>。</p><p>如下图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874227325941.png" alt="20170629149874227325941.png"></p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874228068268.png" alt="20170629149874228068268.png"></p><p>此时，Todey 就可以和主项目进行数据共享了。</p><h4 id="通过-NSUserDefaults-共享数据"><a href="#通过-NSUserDefaults-共享数据" class="headerlink" title="通过 NSUserDefaults 共享数据"></a>通过 NSUserDefaults 共享数据</h4><p>当用户登录成功后，保存用户的积分到本地供 Widget 读取并展示。</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 保存积分供 Widget 使用</span></div><div class="line"> <span class="built_in">NSUserDefaults</span> *shared = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:<span class="string">@"group.com.xiaozhumi.today"</span>];</div><div class="line"> [shared setObject:jf forKey:<span class="string">@"UserJF"</span>];</div><div class="line"> [shared synchronize];</div></pre></td></tr></table></figure><p>widget 读取积分</p><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *shared = [[<span class="built_in">NSUserDefaults</span> alloc] initWithSuiteName:<span class="string">@"group.com.xiaozhumi.today"</span>];</div><div class="line"><span class="built_in">NSString</span> *value = [shared valueForKey:<span class="string">@"UserJF"</span>];</div></pre></td></tr></table></figure><p>展示结果如图所示：</p><p><img src="http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149874261861798.png" alt="20170629149874261861798.png"></p><h4 id="通过-NSFileManager-共享数据"><a href="#通过-NSFileManager-共享数据" class="headerlink" title="通过 NSFileManager 共享数据"></a>通过 NSFileManager 共享数据</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)saveDataByNSFileManager</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xxx.xxx"</span>];</div><div class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"Library/Caches/test"</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *value = <span class="string">@"test"</span>;</div><div class="line">    <span class="built_in">BOOL</span> result = [value writeToURL:containerURL atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"save value:%@ success."</span>,value);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)readDataByNSFileManager</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSURL</span> *containerURL = [[<span class="built_in">NSFileManager</span> defaultManager] containerURLForSecurityApplicationGroupIdentifier:<span class="string">@"group.com.xxx.xxx"</span>];</div><div class="line">    containerURL = [containerURL URLByAppendingPathComponent:<span class="string">@"Library/Caches/test"</span>];</div><div class="line">    <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithContentsOfURL:containerURL encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，基本已经实现了 widget 的基本功能。由于本文是在实际项目中截图记录的，所以暂不提供Demo查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;添加-Today-Extension-工程&quot;&gt;&lt;a href=&quot;#添加-Today-Extension-工程&quot; class=&quot;headerlink&quot; title=&quot;添加 Today Extension 工程&quot;&gt;&lt;/a&gt;添加 Today Extension 工程&lt;/h3&gt;&lt;p&gt;在原有的项目基础上，想要使用 &lt;code&gt;Today Extension&lt;/code&gt;，即 &lt;code&gt;Widget&lt;/code&gt;。我们需要创建一个新的 &lt;code&gt;target&lt;/code&gt;，点击&lt;code&gt;File--&amp;gt;New--&amp;gt;Target--&amp;gt;Today Extention&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhangdinghao-blog.test.upcdn.net/blog-img/20170629149873901496022.png&quot; alt=&quot;20170629149873901496022.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhangdinghao-blog.test.upcdn.net/blog-img/2017062914987390541464.png&quot; alt=&quot;2017062914987390541464.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOSDev" scheme="http://CalvinCheung.coding.me/categories/iOSDev/"/>
    
    
      <category term="ObjC" scheme="http://CalvinCheung.coding.me/tags/ObjC/"/>
    
  </entry>
  
</feed>
